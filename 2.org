* if-let-key, ifn-let-key, and if-failed
I am not sure if I am going to use macros =if-let-key= and =ifn-let-key= a lot,
so let me define them here instead of [[https://github.com/chalaev/lisp-goodies][lisp-goodies]] project.

=if-let-key= has an extra parameter – =key= function:
#+BEGIN_SRC emacs-lisp :tangle generated/2.el :shebang ";; -*-  lexical-binding: t; -*-"
(defmacro if-let-key (key vars if-yes &rest if-no)
  `(let ((,(caar vars) ,(cadar vars)))
     (if (funcall ,key ,(caar vars))
	 ,(if(cdr vars)
	      (macroexpand-1 `(if-let-key ,key ,(cdr vars) ,if-yes ,@if-no))
	    if-yes)
       ,@if-no)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defmacro ifn-let-key (key vars if-yes &rest if-no)
  `(let ((,(caar vars) ,(cadar vars)))
     (ifn (funcall ,key ,(caar vars))
	 ,(if(cdr vars)
	      (macroexpand-1 `(if-let-key ,key ,(cdr vars) ,if-yes ,@if-no))
	    if-yes)
       ,@if-no)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 `(if-let-key #'car ((r1 '(nil . :bad)) (r2 '(1 . :good))) 1 2 3 4))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((r1 (quote (nil . :bad)))) (if (funcall (function car) r1) (let ((r2 (quote (1 . :good)))) (if (funcall (function car) r2) 1 2 3 4)) 2 3 4))
:END:

Formatted output:
#+BEGIN_SRC emacs-lisp
(let ((r1 (quote (nil . :bad))))
  (if (funcall (function car) r1)
      (let ((r2 (quote (1 . :good))))
	(if (funcall (function car) r2)
	    1 2 3 4))
    2 3 4))
#+END_SRC
←  we see that =ifno= (which could be a big block of code) is duplicated, and I do not like this.
(It's gonna be triplicated if there are 3 variables, and so on.)

#+BEGIN_SRC emacs-lisp :tangle generated/micro-2.el
(ert-deftest if-let-key()
  (should (eql :yes (if-let-key #'id ((a "a") (b (concat a "b")))
		      :yes
		      (when (boundp 'b) (setf b (concat b "a")))
		      (setf a (concat a "a"))
		      (if (boundp 'b) (concat a b) a))))
  (should (eql :nil (if-let-key #'car ((a nil) (b (concat a "b")))
		      :yes
		      (when (boundp 'b) (setf b (concat b "a")))
		      :nil)))
  (should (= 3 (if-let-key #'car ((a '(1 . 2)) (b '(nil . 3)))
		 :yes
		 (cdr b)))))
#+END_SRC

=if-let-key= seems to be useful only for (simplest) one-variable let-declarations:
#+BEGIN_SRC emacs-lisp :tangle generated/micro-2.el
(ert-deftest if-let-key()
  (should (= 1 (ifn-let-key #'car ((r1 '(nil . :bad))) 1 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defmacro if-failed(expr err-msg &rest body)
(let ((expr-result (s-gensym "ER")))
  `(ifn-let-key #'car ((,expr-result ,expr))
(let ((emsg (cons :error (cond
((stringp ,err-msg) (list (concat ,err-msg "
because " (cdr ,expr-result))))
((listp ,err-msg) (cons(concat(car ,err-msg) "
because " (cdr ,expr-result)) (cdr ,err-msg)))
(t (list (cdr ,expr-result)))))))
(setf ok nil)
#+END_SRC
Now we've got =err-msg= which is a list of arguments ready for =clog=.

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(cons (apply #'clog emsg) (apply #'format (cdr emsg))))
,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/micro-2.el
(ert-deftest if-failed()
(clog :info "IGNORE the following :error log message which is part of a test:")
(let* ((ok t) (IFFA (if-failed '(nil . "it's too bad!") "tutto cazzo" 1)))
  (should  (not ok))
  (should (not (car IFFA)))
  (should (string= "tutto cazzo
because it's too bad!" (cdr IFFA))))
(clog :info "IGNORE the following :error log message which is part of a test:")
(let* ((ok t) (IFFA (if-failed '(nil . "there is a big problem") '("could not encrypt %s to %s" "aaa.txt" "bbb.gpg") 2)))
  (should (not ok))
  (should (not (car IFFA)))
  (should (string= "could not encrypt aaa.txt to bbb.gpg
because there is a big problem" (cdr IFFA))))
(let* ((ok t))
(should (and ok (= 3 (if-failed '(t . "there is a big problem") '("could not encrypt %s to %s" "aaa.txt" "bbb.gpg") 3))))))
#+END_SRC
where one can use =(ert-run-test (ert-get-test 'if-failed))= for interactive testing.

I am not sure if the following code is really useful:
#+BEGIN_SRC emacs-lisp
(defmacro when-failed (expr err-msg &rest body)
(let ((expr-result (s-gensym "ER")))
  `(unless-let #'car ((,expr-result ,expr))
(let ((emsg (cons :error (cond
((stringp ,err-msg) (list (concat ,err-msg " because " (cdr ,expr-result))))
((listp ,err-msg) (cons(concat(car ,err-msg) " because " (cdr ,expr-result)) (cdr ,err-msg)))
(t (list (cdr ,expr-result)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro failed(&rest msg)
`(progn
   (apply #'clog (cons :error ,msg))
   (setf ok nil)))
#+END_SRC

* Other code
BTW, =(file-exists-p FN)= produces ~nil~ if the file resides in directory with (rx) permissions →
#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun get-file-properties* (FN)
  (when-let ((FA (and (file-exists-p FN) (file-attributes FN 'string)))
	     (DB-rec (make-vector (length file-fields) nil)))
      (destructuring-bind
	  (uid gid acess-time mod-time status-time fsize ms void inode fsNum)
	  (cddr FA)
	(aset DB-rec size fsize)
	(aset DB-rec gname gid)
	(aset DB-rec mtime mod-time); list of 4 integers
	(aset DB-rec modes (perms-from-str ms))
	(aset DB-rec plain FN); (aset DB-rec write-me to-cloud); might be later adjusted in read-fileDB
	DB-rec)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun get-file-properties (FN)
  (or (cloud-locate-FN FN) (get-file-properties* (file-chase-links FN))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun cip-ext (FN)
"extension of encrypted file based on the original name"
(case* (file-name-extension FN) string=
       ("jpeg" ".png")
       ("jpg" ".png")
       (otherwise ".gpg")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun forget-password(XYZ)
  "removes image password from password file"
(let* ((str (progn
	     (find-file (image-passes))
	     (buffer-string)))
       (BN (buffer-name)))
  (with-temp-file (image-passes)
    (insert (replace-regexp-in-string (format "%s .*
" XYZ) "" str)))
  (kill-buffer BN)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defmacro bad-column (cType N &optional str)
(if str
`(clog :error "invalid %dth column in %s line = %s" ,N ,cType ,str)
`(clog :error "invalid %dth column in %s line" ,N ,cType)))
#+END_SRC

2020-11-02 I observed a strange ~gpg~ error: when I encrypted directly to the cloud directory,
sometimes I could not unencrypt it as if there were some write errors!
So I decided that I will first encrypt the file locally and then move it to the folder.

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun gpg-encrypt(FN XYZ)
(let ((tmp-gpg-file (concat (/tmp/cloud/) XYZ ".gpg")))
(ifn (= 0 (apply #'call-process
     (append (list "gpg" nil nil nil)
(split-string (format "--batch --yes --pinentry-mode loopback --passphrase %S -o %s --symmetric %s"
    password tmp-gpg-file (untilde FN))))))
(let ((msg (format "failed to encrypt %s to %s!" (local/all) remote/files)))
(cons (clog :error msg) msg))
#+END_SRC
← foreground encryption. Probably I should have merged it with the =Makefile= and make background.

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(mv tmp-gpg-file (concat (remote-directory) XYZ ".gpg")))))
#+END_SRC
← returns usual (standard for me) structure =(successP . more-details)=

#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun gpg-decrypt(FN XYZ)
(clog :debug "decrypting %s to %s" XYZ FN)
(let ((tmp-gpg (concat (/tmp/cloud/) XYZ ".gpg"))
      (RD-XYZ (concat (remote-directory) XYZ ".gpg")))
  (ifn-let-key #'car ((cpr (cp RD-XYZ tmp-gpg)))
     (cons (clog :error "failed: cp %s %s because %s" RD-XYZ tmp-gpg (cdr cpr)) (cdr cpr))
  (ifn (= 0 (apply #'call-process
(append (list "gpg" nil nil nil)
(split-string (format "--batch --yes --pinentry-mode loopback --passphrase %S -o %s --decrypt %s"
		      password (untilde FN) tmp-gpg)))))
       (cons (clog :error "failed to encrypt %s to %s!" (local/all) remote/files) "make failed")
(rm tmp-gpg)))))
#+END_SRC

The problem: =(safe-dired-delete)= asks for permission to recursively delete directory,
even in (non-interactive) text mode, when I launch =emacs --daemon=!
#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun safe-dired-delete (FN)
  (condition-case err (cons t (funcall DDF FN "always"))
    (file-error
      (cons nil (clog :error "in DDF: %s" (error-message-string err))))))
#+END_SRC

In =time<= I have to add 3 seconds of time to avoid chatter effects:
if at some moment the files are synchronized between the host and the cloud,
this situation might change due to time-desynchronization.
#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun time< (t1 t2)
  (and
    (time-less-p (time-add t1 3) t2)
    (not (time-less-p (time-add t2 3) t1))))
#+END_SRC
This problem demonstrates the importance of the time synchronization (via =ntpdate= or an =ntp= server);
however, it is not too serious because it just results in useless downloading or uploading,
with replacement of files with their exact copies. This should not result in data loss.

Not that important, still handy function replacing file extension:
#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun replace-file-ext(FN new-ext)
  "replacing file extension"
  (concat (file-name-sans-extension FN) "." new-ext))
#+END_SRC

Choosing the youngest (most recently updated) file out of the list:
#+BEGIN_SRC emacs-lisp :tangle generated/2.el
(defun youngest(&rest FNs)
  (car (sort FNs #'file-newer-than-file-p)))
#+END_SRC
