#+TITLE: emacs-based secure cloud storage for text files
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

Uses ~macros.el~, ~functions.el~, ~file-functions.el~, and ~logging.el~ from the [[https://notabug.org/shalaev/lisp-goodies][lisp-goodies]] project.

Github vs Emacs: since ~github~
1. does not understand ~org-mode~ internal links,
2. does not show calculation results from ~org~ files and
3. can not hide selected sections (thus making the web page too long),
consider opening this file in ~emacs~ instead of watching it online.

* Symmetric (en/de)cryption
All hosts (computers) are treated identically – there is no "main" host. This is why we use symmetric encryption
with automatically generated password. 
For (en/de)cryption, emacs will call shell commands similar to
#+BEGIN_SRC shell
gpg --pinentry-mode loopback --passphrase "somepass" -o /mnt/cloud/abc.gpg --symmetric ~/myFile.txt
gpg --pinentry-mode loopback --passphrase "somepass" -o ~/myFile.txt --decrypt /mnt/cloud/abc.gpg
#+END_SRC

* Initialization
Although [[https://stallman.org/][Stallman]] recommends not to use ~CL~, for now I am still requiring it.
** Local configuration
*** variables (configuration parameters)
The variables with the names starting with "cloud-" should probably be kept global; the others will be "localized".

=cloud-file-hooks= is used for special files (e.g., diary or bookmarks);
When those are copied from the cloud to the local hard drive, one should call, e.g., =diary-view-entries= or =bookmark-load=:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from cloud.org
(defvar password nil); to be read from config or generated
(defvar number-of-CPU-cores 1)
(defvar cloud-file-hooks nil "for special files treatment")
#+END_SRC
← for example, after we have updated local ~emacs-diary~ file from the cloud, we may want to re-scan it.

#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar upload-queue nil "names of edited files")
(defvar added-files nil "newly clouded files")
#+END_SRC

From time to time (e.g., when we =M-x cloud-sync=)  we synchronize local information
with the remote file whose (secret) name is stored in =remote/files=:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar remote/files nil "3-symbol DB name on the server, e.g., WzT")
(defvar localhost (system-name))
(defvar ~ (file-name-as-directory(expand-file-name "~")))
(defvar remote-directory  "/mnt/cloud/")
#+END_SRC
← for portability it is better to avoid backslashes in path names.

#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar /tmp/cloud/ (file-name-as-directory (make-temp-file "cloud." t)))
(defun remote/files() remote/files)
(defun remote-directory() remote-directory)
(defun remote-files() (concat (remote-directory) remote/files ".gpg"))
(defun history() (concat (remote-directory) "history"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar emacs-d "~/.emacs.d/")
(defvar cloud-was-connected t "normally t, nill when there was no connection")
#+END_SRC
← ~cloud-was-connected~ is set to ~nil~ when ~(cloud-sync)~ fails, and is set to ~t~ once =(read-fileDB)= succeeds.

Similarly to how they do it in ~JavaScript~, let me call the following functions "dynamic variables":
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defun local-dir() (concat emacs-d "cloud/"))
(defun cloud-mk() (concat (local-dir) "cloud.mk"))
(defun lock-dir() (concat (remote-directory) "now-syncing/"))
(defun image-passes() (concat (local-dir) "individual.passes"))
(defun local/() (concat (local-dir) localhost "/"))
(defun local/log() (concat (local/) "log"))
#+END_SRC

Instead of storing configuration in =~/.emacs= I prefer to store it in a separate file:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defun local/config() (concat (local-dir) localhost "/config"))
#+END_SRC
This is because
1. sometimes the code will update its configuration, and
2. in this way configuration data is more separated from other ~elisp~ programs.

*** creating (only once, during the first run)
Before we start for the very first time, when cloud directory is inexistent or empty, 
we create the password for encryption by =(cloud-init)=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-init() "initializes cloud directory and generates password -- runs only once"
(clog :info "atempting to create new configuration for this host")
;;(when (yes-or-no-p "Is cloud mounted?")
;;(setf remote-directory (read-string "cloud directory=" remote-directory))
(ifn (member (safe-mkdir remote-directory) '(:exists t))
(clog :error "could not create/access directory %s" remote-directory)
#+END_SRC
For safety reasons refusing to initialize a directory already containing encrypted files:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(if (directory-files remote-directory nil "^.\+.gpg$" t)
    (clog :error "please clean the directory %s before asking me to initialize it" remote-directory)
(clog :info "creating (main) remote file DB in unused directory %s" remote-directory)
(ifn-set ((remote/files (new-file-name remote-directory)))
  (clog :error "could not create DB file in the directory %s" remote-directory)
#+END_SRC
Generating random password and saving it in the local configuration file:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(setf password (rand-str 9))
#+END_SRC
– one password for all text files – 
for now this software is designed for single person only, and I do not see why should I use individual passwords for different
text files. 

#+begin_note
I already use individual passwords for images so (from the technical point of view) it is easy to use
individuall passwords for some (or all) text files ← might facilitate gradual password replacement.
#+end_note

The concept "one password for many text files" might be changed later if I ever upgrade the code for sharing files within a group of people;
but if this happens, I will probably have to abandon symmetric encryption and deal with public/private keys.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(ifn (member (safe-mkdir (local-dir)) '(:exists t))
  (clog :error "could not create/acess directory %s" (local-dir))
(write-conf)
(clog :info "use M-x cloud-add in the dired to cloud important files and directories" ))))))
#+END_SRC

*** reading and writing
By default we assume that our configuration parameters have a string value. There are exceptions:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar numerical-parameters '("number-of-CPU-cores"))
(defvar lists-of-strings '("junk-extensions" "ignored-dirs"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun format-conf(CP)
(cond
  ((member CP numerical-parameters) (format "%s=%d" CP (symbol-value(intern CP))))
  ((member CP lists-of-strings) (format "%s=%s" CP
(apply #'concat (mapcar #'(lambda(item) (format "%s " item)) (sort (symbol-value(intern CP)) #'string<)))))
  (t (format "%s=%s" CP (symbol-value(intern CP))))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.el
(ert-deftest format-conf()
(let ((numerical-parameters '("number-of-CPU-cores"))
      (number-of-CPU-cores 123))
  (should (string= "number-of-CPU-cores=123"
     (format-conf "number-of-CPU-cores")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun write-conf()
(clog :debug "starting write-conf")
(with-temp-file (local/config)
(mapcar #'(lambda(CP) (insert(format-conf CP)) (newline)) 
  '("remote-directory" "junk-extensions" "ignored-dirs" "remote/files" "number-of-CPU-cores" "password")))
(clog :debug "ended write-conf") t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun read-conf* (file-name)
  "reads configuration file"
(with-temp-buffer
(safe-insert-file (local/config))
  (let (res str)
    (while (< 0 (length (setf str (read-line))))
     (if (string-match "^\\(\\ca+\\)=\\(\\ca+\\)$" str)
	 (push (cons (match-string 1 str) (match-string 2 str)) res)
       (clog :error "garbage string in configuration file: %s" str)))
    res)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun read-conf()
  "reads configuration file"
(let ((conf (read-conf* (local/config))))
(ifn conf (clog :error "refuse to work until you specify 3-symbol contents name \"remote/files\" in %s" (local/config))
(dolist (CP (mapcar #'car conf))
(clog :debug "read-conf(%s)" CP)
  (setcdr (assoc CP conf)
    (cond
((member CP numerical-parameters) (string-to-number (cdr (assoc CP conf))))
((member CP lists-of-strings)  (split-string (cdr (assoc CP conf))))
(t (car (split-string (cdr (assoc CP conf))))))))
(clog :debug "done with read-conf")
conf)))
;; 2020-11-20 (car (split-string "/mnt/cloud/"))
#+END_SRC

** Host/Action/File information
*** general
We got three variables (or databases) describing
1. host names participating in file synchronization,
2. actions to be performed on other hosts, and
3. names of the clouded files:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar cloud-hosts nil "host names participating in file synchronization")
(defvar remote-actions nil "actions to be saved in the cloud")
(defvar file-DB nil "list of vectors, each corresponding to a clouded file")
#+END_SRC
← The content of these variables is stored
1. in RAM: (=cloud-hosts=, =remote-actions=, =file-DB=),
2. in local file named =(local/all)=
3. on the server, in a file named =remote/files=.

We have to manually blacklist files generated by emacs, see ~README.md~ stanza in [[file:Makefile][Makefile]]:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar *blacklist* '("~/.bash_login" "~/.bash_logout" "~/.bashrc") "list of manually blcklisted files")
#+END_SRC
← temporary solution for dot files.

The following block will probably not be used:
#+BEGIN_SRC emacs-lisp
(defun blacklisted(FN)
(or(member FN *blacklist*)
(when (member FN *onetime-blacklist*) (drop *onetime-blacklist* FN) t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar ignored-dirs '("/tmp/" "/mnt/" "/etc/") "temporary or system or remote directories")
#+END_SRC

Suppose we opened a ~dired~ buffer, and =M-x cloud-add= on a directory. Files with certain extensions in the (sub)directory should not be clouded by default:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar junk-extensions '("ac3" "afm" "aux" "idx" "ilg" "ind" "avi" "bak" "bbl" "blg" "brf" "bst" "bz2" "cache" "chm" "cp" "cps" "dat" "deb" "dvi" "dv" "eps" "fb2"
"fn" "fls" "img" "iso" "gpx" "segments" "ky" "mjpeg" "m" "md" "mov" "mpg" "mkv" "jpg" "gif" "jpeg" "png" "log" "mp3" "mp4" "m2v" "ogg" "ogm" "out" "part" "pbm" "pdf"
"pfb" "pg" "pod" "pgm" "pnm" "ps" "rar" "raw" "gz" "sfd" "woff" "tbz" "tgz" "tga" "tif" "tiff" "toc" "tp" "vob" "vr" "wav" "xcf" "xml" "xz" "Z" "zip")
"files with these extensions will not be *automatically* clouded")
#+END_SRC
← can be overwritten by config file.

Every element of ~file-DB~ is a vector having the following structure:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar file-fields; indices numerating array fields
(list 'plain; original (local) file name
'cipher; encrypted file name (base name)
'mtime; modification time
'modes; permissions
'size; file size (should not be saved)
'gname)); group name
(let ((i 0)) (dolist (field-name file-fields) (setf i (1+ (set field-name i)))))
#+END_SRC

*** hosts and actions
The content of ~file-DB~ is locally stored in the file named =(local/all)=:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defun local/all() (concat (local/) "all"))
#+END_SRC

*** printing
**** hosts
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun print-hosts()
  (dolist (hostname cloud-hosts) (insert (format "%s " hostname)))
  (backspace)
  (newline))
#+END_SRC
**** actions
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun print-actions()
(dolist (action remote-actions)
  (clog :debug "printing-action %s" (format-action action))
  (insert (format-action action))
  (drop remote-actions action)
  ;;(backspace) 
(newline)))
#+END_SRC
**** file info
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun format-file (DB-rec)
  (format "%S %s %s %s %d %S"
	  (tilda (aref DB-rec plain))
	  (aref DB-rec cipher)
	  (aref DB-rec size)
	  (aref DB-rec gname)
	  (aref DB-rec modes); integer
	  (format-time-string "%F %H:%M:%S %Z" (aref DB-rec mtime))))
#+END_SRC

*** parsing
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun safe-FL()
  (if (< (line-end-position) (point-max))
     (forward-line)
     (move-end-of-line 1)))
(defun read-line()
(let ((str (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
 (safe-FL)
 str))
(defun cut-line() 
(let ((str (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
  (delete-region (line-beginning-position) (progn (safe-FL) (point)))
   str))
#+END_SRC

**** action lines
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-action(str)
(clog :debug "parse-action(%s) ..." str)
(let ((action (make-vector (length action-fields) nil)))
#+END_SRC
An action string has unknown number of fields (columns); some of them are quoted and may contain spaces, others are not.
We use =begins-with= from ~common.el~ to read the fields.

Let us parse the string =str= and save extracted parameters (values) in the vector =action=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(dolist (column (list
                 `(:time-stamp . ,i-time)
                 `(:int . ,i-ID)
                 `(:int . ,i-Nargs)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
=(aref action i-Nargs)= must be evaluated _after_ =`(:int . ,i-Nargs)=, but _before_ we proceed with =(cons (cons  :string  (aref action i-Nargs)) i-args)=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(dolist (column 
(list
  (cons (cons  :string  (aref action i-Nargs)) i-args)
       `(:strings . ,i-hostnames)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value)); was (mapcar #'untilda (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
So, we have just got information about pending action.
We perform it immediately if our hostname is in the list =(aref action i-hostnames)=.

In this sigle-user code action's time stamp =AID= may serve as its unique ID:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(let ((AID (format-time-string "%02m/%02d %H:%M:%S" (aref action i-time))))
(clog :info "... will later be referenced as %s" AID)
(cons AID action))))
#+END_SRC

**** file lines
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun str-to-DBrec(str)
"parses one file line from the remote file DB"
(ifn (string-match "\"\\(.+\\)\"\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([[:digit:]]+\\)\s+\"\\(.+\\)\"" str)
(clog :error "Ignoring invalid file line %s" str)
#+END_SRC
We've got a valid string describing a clouded file, now let us parse it.
The first column is the file name:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(let ((CF (make-vector (length file-fields) nil))
      (FN (match-string 1 str)))
  (aset CF plain FN)
  (aset CF cipher (match-string 2 str))
  (aset CF size (string-to-number (match-string 3 str)))
#+END_SRC
← the last field is no more used.

We syncronize ~gname~ (name of the group), ~modes~ (permissions), and ~mtime~ (modification time) for every file:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
  (aset CF gname (match-string 4 str))
  (aset CF modes (string-to-number (match-string 5 str)))
  (let ((mtime-str (match-string 6 str)))
(ifn (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [[:upper:]]\\{3\\}" mtime-str)
(bad-column "file" 6 mtime-str)
(aset CF mtime (parse-time mtime-str))
CF)))))
#+END_SRC

** (En/De)cryption
Especially when ~(= 0 *log-level*)~ this code might print many log messages.
For most important ones I will use this function
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun end-log (fstr &rest args)
  "message + time"
  (push
   (apply #'format
	  (cons (concat
		 (format-time-string "%H:%M:%S " (apply 'encode-time (butlast (decode-time (current-time)) 3)))
		 fstr)
		args))
   important-msgs))
#+END_SRC
which is going to print them at the end of the syncronization session.

Some files require special treatment after they are updated on the local disk from the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun post-decrypt (FN)
  "special treatment for certain files"
  (let ((ext (file-name-extension FN))
	(name (file-name-base FN)))
    (when (string= FN (expand-file-name diary-file))
      (with-current-buffer (find-file-noselect (diary-check-diary-file))
	(clog :info "diary buffer opened or updated")))
     (when (member FN *loaded*)
       (end-log "*configuration changed, consider reloading emacs*")
    (clog :warning "consider reloading configuration file %s" FN)
    ;;   (load-file FN))
)))
#+END_SRC
where =diary-check-diary-file= will raise an error (exception) in case of inexisting diary-file.

** Other variables
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar removed-files  nil "files that were just removed (or renamed or forgotten) on local host before (cloud-sync)")
#+END_SRC
← this variable serves to prevent recovering them from the cloud during the next =M-x cloud-sync=.
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar important-msgs nil "these messages will be typically printed at the end of the process")
(defvar gpg-process nil "assyncronous make-process for (en/de)cryption")
#+END_SRC

* Connection with the cloud
Checking if the internet connection is established:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-connected-p()
  (and
   (remote-directory) (remote/files)
   (file-readable-p remote-directory)))
;;(file-readable-p (remote-files)
#+END_SRC
#+begin_note
=cloud-connected-p= should *not* be called before local file has been read by =read-conf=.
#+end_note

** SSH
Sometimes internet connection can be unstable or shut down unexpectedly,
so I added ~reconnect~ option to the ~/etc/fstab~ entry
(this probably will not work if you have to supply password to unlock the ssh key):
#+BEGIN_SRC 
# /etc/fstab
sshfs#shalaev@leanws.com: /mnt/lws fuse reconnect,users,auto 0 0
#+END_SRC
where "shalaev" is my user name, and ~leanws.com~ is the ssh-server (replace these with your values).

To limit the timeout to 30 seconds, update =~/.ssh/config= as follows:
#+name: ssh-config
#+BEGIN_SRC
# ~/.ssh/config
ServerAliveInterval 15
ServerAliveCountMax 2
#+END_SRC

** WebDav
=WebDav= is much slower than =ssh=, but it should be ok for file synchronization.
To mount ~yandex~ or ~pcloud~ to local directories ~/mnt/yd/~ and ~/mnt/pc~ I need three files:
~/etc/fstab~, ~/etc/davfs2/davfs2.conf~, and ~/etc/davfs2/secrets~
#+BEGIN_SRC 
# /etc/fstab
https://webdav.yandex.ru        /mnt/yd	davfs   user,noauto,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
https://webdav.pcloud.com	/mnt/pc	davfs	user,noauto,uid=shalaev,gid=shalaev,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
#+END_SRC
where ~shalaev~ is my user name and group name; you must replace it with yours.

#+BEGIN_SRC
# /etc/davfs2/davfs2.conf
dav_user        davfs2
dav_group       davfs2
use_locks	0
cache_dir       /var/cache/davfs2 # system wide cache
cache_size      5000              # MiByte
delay_upload	0
#+END_SRC

#+BEGIN_SRC
# /etc/davfs2/secrets
/mnt/yd	myYandexLogin		password
/mnt/pc	myPCloudLogin		password
#+END_SRC

** FTP
Somehow I am not aware of /reliable/ way of mounting an ~ftp~ server to a directory in linux;
~emacs~ also seems to be bad in estsblishing ~ftp~ connections.
May be developers think that ~ftp~ is obsolete and ignore it;
personally I don't see anything wrong with it, especially when an ~ftp~ connection is established using SSL-encryption.

Probably the best way to improve FTP-support in emacs would be to write an eLisp-wrapper for [[http://lftp.yar.ru][lftp]] command.

* Remote file DB
This file stores [[Host/Action/File information][Host/Action/File information]] on the server.
** Writing
*** The first line: list of all hostnames
←  without quotes, separated by spaces.

In the following, ~DBname~ is the name of _decrypted_ remote file DB:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun write-all (DBname)
  (with-temp-file DBname
(print-hosts)
#+END_SRC
Probably I should *not* write the file if both =upload-queue= and =added-files= are nil.

The next block of lines contains information about pending [[Actions][actions]] →

*** Pending actions
In this block, every line is has the following fields (columns):
1. Time stamp,
2. (integer) action ID,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).
   Gets updated by =cloud-host-add= and =cloud-host-forget=.

The order of actions is important! For example, imagine that
I renamed or moved a file twice; the order of these actions on a remote host should be the as on the local one:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(print-actions)
#+END_SRC
Pending actions block is ended by an empty line separating it from the rest of the file:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(newline)
#+END_SRC

*** List of clouded files
This is the last (and, usually, the largest) block of lines.
Here every line corresponds to one file:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(dolist (file-record file-DB)
  (insert (format-file file-record)) (newline))
(setf removed-files nil) t))
#+END_SRC
← Also =removed-files= is set to =nil= in =cloud-sync=; probably it's enough to reset it only there.

** Parsing
*** list of host names
The function =read-all= (returns =nil=) reads (previously decrypted) [[Host/Action/File information][host/action/file information]]:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun read-all(DBname)
  "reads content (text) file into the database file-DB"
  (temp-open DBname
  (let (str)
(needs-set
 ((cloud-hosts
  (split-string (setf str (read-line)))
  (clog :error "invalid first line in the remote file DB %s" DBname)))
#+END_SRC
In case =read-all= is launched on an unknown computer
(that is, its hostname is not yet mentioned in the first line of the file =DBname=),
it is automatically added to the cloud network:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (member localhost cloud-hosts) (cloud-host-add))
#+END_SRC

*** list of pending actions
The concept of actions is explained in the [[Actions][corresponding section]].

Keep reading one action after another until we encounter an empty line:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(while (< 0 (length (setf str (read-line))))
(clog :debug "action string=%s" str)
(when-let ((AA (parse-action str)) (AID (car AA)) (action (cdr AA)))
  (ifn (member localhost (aref action i-hostnames))
      (clog :info "this host is unaffected by action %s" AID)
    (if (perform action (aref action i-hostnames))
	(clog :info "sucessfully performed action %s" AID)
      (clog :error " action %s failed, will NOT retry it" AID))
#+END_SRC
← even if the action failed, we wash our hands and not retry it.
If the action is still pending on some hosts, we will store it in =remote-actions=
which is going later to be saved into the [[Contents file][remote file DB]]:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(when (drop (aref action i-hostnames) localhost)
  (end-push action remote-actions)))))
#+END_SRC

An empty line ends the action reading loop;
the next thing to do is to read/parse the files' block of lines.

*** list of (clouded) files
For files that need to be (up/down)loaded (to/from) the cloud =(read-fileDB)= forms ~cloud.mk~
which can be fed to GNU make as =make --jobs=N -f cloud.mk=, where ~jobs~ parameter ~N~ is the (configurable) number of CPU cores.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(needs ((CDFs
#+END_SRC
← =CDFs= will contain the data about the files in the remote directory.

Our ~.gpg~ files are named as  ~XYZ.gpg~; the next line cuts the extension  ~.gpg~ away:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
 (mapcar #'(lambda(s) (replace-regexp-in-string "....$" "" s))
      (directory-files remote-directory nil "...\...." t)) (clog :error "can not read %s" remote-directory)))
(while(< 10 (length (setf str (read-line))))
(when-let((CF (str-to-DBrec str)))
#+END_SRC
Ideally every file mentioned in =file-DB= should exist on a local hard disk.
In reality either file, the local one, or the remote one, or both, might be absent,
and we have to address all of these situations:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(let* ((FN (plain-name CF))
       (CN (aref CF cipher))
       (remote-file-exists (member CN CDFs))
       (local-file-rec (or (cloud-locate-FN FN)
(and (not (member FN removed-files))
(when-let ((LF (get-file-properties* FN)))
        (aset LF cipher (aref CF cipher))
        (push LF file-DB)
        LF)))))
(cond
((not (or local-file-rec remote-file-exists))
 (clog :error "forgetting file %s which is marked as clouded but is neither on local disk nor in the cloud" FN)
 (drop file-DB CF))
((or
 (and (not local-file-rec) remote-file-exists)
 (and local-file-rec remote-file-exists (time< (aref local-file-rec mtime) (aref CF mtime))))
(when (and local-file-rec remote-file-exists)
  (clog :debug "read-all/download: %s(%s) is older than %s.gpg(%s)"
  (aref local-file-rec plain) (TS(aref local-file-rec mtime))
  (aref CF cipher) (TS(aref CF mtime))))
#+END_SRC
=download= queues the file for downloading from the cloud (by updating the [[Creating make file][make file]]):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(if local-file-rec
   (aset local-file-rec mtime (aref CF mtime))
   (push CF file-DB))
(let*((DN(file-name-directory(aref CF plain))) (mkdir(safe-mkdir DN)))
(if(or(car mkdir)(eql :exists(cdr mkdir)))
(download CF)
(clog :error "could not mkdir %s" DN))))
((or
 (and local-file-rec remote-file-exists (time< (aref CF mtime) (aref local-file-rec mtime)))
 (and local-file-rec (not remote-file-exists)))
(when (and local-file-rec remote-file-exists)
  (clog :debug "read-all/upload: local %s(%s) is younger than %s.gpg(%s)"
  (aref local-file-rec plain) (TS(aref local-file-rec mtime))
  (aref CF cipher) (TS(aref CF mtime))))
(upload CF))))))
t)))))
#+END_SRC
← similarly, =upload= queues the file for uploading to the cloud.

At this point we ended up parsing the list of files.
=(defun read-all ...)= ends here.

* On saving files in emacs
When the file is saved in emacs (=C-x s=), we mark it so that it is going
to be uploaded to the cloud when the user calls =cloud-sync= next time:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun touch (FN)
"called when the file named FN is changed"
(when (and FN (stringp FN))
  (when-let ((file-data (cloud-locate-FN FN)))
    (aset file-data mtime (current-time))
    (clog :debug "touch/upload: %s(%s)" FN (TS(aref file-data mtime)))
    (upload file-data) t)))
(defun on-current-buffer-save()
  (when-let ((FN (buffer-file-name)))
    (and (auto-add-file FN) (touch FN))))
(add-hook 'after-save-hook 'on-current-buffer-save)
#+END_SRC
* Creating make file
Make file is useful because
1. it allows us to use multi-threading and
2. it simplifies debugging.

When the make file is ready, we launch it with =make -jN ~/.emacs.d/cloud/cloud.mk=, where =N= is the number of CPU cores. 
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(macrolet ((NL () '(push "
" Makefile))
(inl (&rest format-pars) `(progn (push ,(cons 'format format-pars) Makefile) (NL))))
(let (all Makefile uploaded
#+END_SRC
(Already encrypted) gpg-files types are not supposed to be encrypted, and images should be encrypted in a special way.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(specially-encoded '(
#+END_SRC
Already encrypted (~gpg~) files are just copied
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
("$(cloud)%s.gpg: %s
\tcp $< $@
" "gpg")
#+END_SRC
← this format string requires 2 arguments: =(aref file-record cipher)= and =(aref file-record plain)=.

Make stanza for encrypting an image is more sophisticated:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
("$(cloud)%s.png: %s %s
\tconvert $< -encipher %s%s $@
" "jpg" "jpeg" "png")))
#+END_SRC
← this format string requires 5 arguments:
=(aref file-record cipher)=, =(aref file-record plain)=, =(updated)=,
=(pass-d)=, and (once again) =(aref file-record cipher)=.

Similarly, for decoding
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(specially-decoded '(
("%s: $(cloud)%s.gpg
\tcp $< $@
" "gpg")
("%s: $(cloud)%s.png  %s
\tconvert $< -decipher %s%s $@
" "jpg" "jpeg" "png"))))
#+END_SRC
with the same number of arguments, as for encoding above.

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cancel-pending-upload(FN) (drop all FN))
(cl-labels ((pass-d () (concat (local-dir) "pass.d/"))
          (updated() (concat (pass-d) "updated")))
#+END_SRC

** Creating ~make~ stanza for encoding one file
Non-standard case (an image or a ~gpg~-file):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(cl-flet ((enc-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-encoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr XYZ FN (updated) (pass-d) XYZ)
#+END_SRC
where ~XYZ~ is the (random) 3-symbol cloud name of the file (without extension).

.gz files receive even more special treatment (involving creation of a temporary file):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(if(string= "gz" file-ext)
(let ((gunzipped (make-temp-file "emacs-cloud.")))
  (format "%s: %s
\tzcat $< > $@

$(cloud)%s.gpg: %s
\t@$(enc) $@ $<
\trm $<
" gunzipped FN XYZ gunzipped))
#+END_SRC

All other files are treated with ~gpg~:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(format "$(cloud)%s.gpg: %s
\t@$(enc) $@ $<
" XYZ FN)))
#+END_SRC
At the end of every file (en/de)coding stanza we send a message to the log file:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(format "\t-echo \"$(date): uploaded %s\" >> $(localLog)
" FN)))))
#+END_SRC
Here ends the function =enc-make-stanza= that produces make-stanza for encoding.

The decoding is similar:
** Creating ~make~ stanza for decoding one file
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(dec-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-decoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr FN XYZ (updated) (pass-d) XYZ)
#+END_SRC

.gz files receive even more special treatment (involving creation of a temporary file):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(if(string= "gz" file-ext)
(let ((gunzipped (make-temp-file "emacs-cloud.")))
  (format "%s: %s
\tcat $< | gzip > $@

%s:$(cloud)%s.gpg
\t@$(enc) $@ $<
\trm $<
" FN gunzipped gunzipped XYZ))
#+END_SRC

All other files are treated with ~gpg~:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(format "%s: $(cloud)%s.gpg
\t@$(dec) $@ $<
" FN XYZ ))
(format "\t-chgrp %s $@
\t-chmod %o $@
\t-touch --date=%S $@
\t-echo \"$(date): downloaded %s\" >> $(localLog)
" (aref file-record gname) (aref file-record modes) (full-TS (aref file-record mtime)) FN)))))))
#+END_SRC

** Putting this all together
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun download (file-record)
(needs ((FN (aref file-record plain) (clog :error "download: file lacks plain name"))
        (stanza (dec-make-stanza file-record) (clog :error "download: could not create stanza for %s" FN)))
(safe-mkdir (file-name-directory FN))
(push (format " %s" FN) all)
(push stanza Makefile) (NL)))
#+END_SRC

GNU make won't upload (with encryption) the file to the server if target is younger than the dependence.
=make-cloud-older= ensures that the ~.gpg~ file is old enough to prevent this behavior:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun make-cloud-older(file-record)
(when-let ((clouded (get-file-properties (aref file-record cipher)))
           (local-mtime (aref file-record mtime)))
(when (time< local-mtime (aref clouded mtime))
(clog :debug "changing time stamp to %s" (FS (time-add local-mtime -60)))
  (set-file-times
(concat (remote-directory) (plain-name clouded) (cip-ext (plain-name file-record)))
(time-add local-mtime (- -60 (random 6000)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun upload (file-record)
(needs ((FN (tilda (aref file-record plain)) (clog :error "upload: file lacks plain name"))
	(CN (aref file-record cipher) (clog :error "upload: file %s lacks cipher name" FN))
	(stanza (enc-make-stanza file-record) (clog :error "upload: could not create stanza for %s" FN)))
(clog :debug "started upload(%s)" FN)
(unless (or (member FN uploaded) (member FN *blacklist*))
(push FN upload-queue)
(clog :debug "will add upload(%s) stanza to Makefile" FN)
(make-cloud-older file-record)
(push FN uploaded)
(push (format " %s" (concat (remote-directory) CN
(cip-ext FN)))
all)
(push stanza Makefile) (NL))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun reset-Makefile()
"reseting make file"
(when (or (and (file-exists-p (pass-d)) (file-directory-p (pass-d))) (safe-mkdir (pass-d)))
(setf all nil Makefile nil uploaded nil)
(inl "cloud=%s" remote-directory)
(inl "password=%S" password)
(inl "gpg=gpg --pinentry-mode loopback --batch --yes")
(inl "enc=$(gpg) --symmetric --passphrase $(password) -o")
(inl "dec=$(gpg) --decrypt   --passphrase $(password) -o")
(inl "localLog=%s" (local/log))
(inl "MK=%s" (cloud-mk))
(inl "date=`date '+%%m/%%d %%T'`
")
(inl (concat (format "%s: %s
\tawk '{print $$2 > %S$$1}' $<
\techo $(date) > $@
\t-chgrp -R tmp %s*
" (updated) (image-passes) (untilda (pass-d)) (pass-d))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun save-Makefile()
"flushing make file"
(inl "all:%s
\techo \"background (en/de)cryption on %s finished $(date)\" >> %s
\t@sed 's/%s/******/g' %s > %s.bak
"
(apply #'concat all)
localhost
(history)
password (cloud-mk) (cloud-mk))
(write-region (apply #'concat (reverse Makefile)) nil (cloud-mk)))))))
#+END_SRC

* cloud-sync
=cloud-sync= is the most frequently used function.

We assume that files are changed only within emacs (either edited/saved or removed/renamed using ~dired~), so that
=file-DB= always contains the most recent information about clouded files.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-sync()
(interactive)
(let ((ok t))
#+END_SRC
Even if the cloud was changed by some other hosts, information from the file named =(local/all)= is still valuable (for resolving collissions)
and must be loaded at start (when =file-DB= is empty):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(ifn (cloud-connected-p) (clog :warning "refuse to sync because remote directory not mounted")
#+END_SRC
Before we start doing whatever with the remote directory (shared among several hosts) let us lock it:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(let ((DL (directory-lock (lock-dir) (format "%s
%s" localhost (TS (current-time)))
#+END_SRC
Now if we realize that another host has uploaded changes to the cloud, we should download them:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(when (file-newer-than-file-p (remote-files) (local/all))
  (clog :info "detected NEW %s, will now update %s from it" (remote-files) (local/all))
  (unless (gpg-decrypt (local/all) (remote/files))
    (setf ok (clog :error "could not decrypt file data from the cloud; SHUT DOWN the service and INVESTIGATE!"))))
#+END_SRC
O.k., now when we've got the most recent version of the file =(local/all)=, let us load and parse it:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (read-all (local/all))
 (setf ok (clog :error "could not parse file data just downloaded from the cloud; SHUT DOWN the service and INVESTIGATE!")))
#+END_SRC
If we made any changes before =(cloud-sync)=, let us upload the updates to the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(when (or added-files upload-queue removed-files)
  (ifn (write-all (local/all)) (setf ok (clog :error "could not save data to %s" (local/all)))
    (gpg-encrypt (local/all) (remote/files))
    (setf added-files nil upload-queue nil removed-files nil)))
#+END_SRC
It is always easier to read local file, so let me make it a little bit younger than the (encrypted) remote one:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(set-file-times (local/all) (current-time))
#+END_SRC
The previous code prepared the make-file; let us call ~GNU make~ now:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(save-Makefile)
(let ((make (format "make -j%d -f %s all &> %s.log" number-of-CPU-cores (cloud-mk) (cloud-mk))))
  (clog :debug "starting %s" make)
  (shell-command make)
  (clog :debug "finished %s" make))
(rm (cloud-mk))
(reset-Makefile))))
#+END_SRC
If director (un)locking fails, we
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (car DL) (setf ok (clog :error "Could not (un)lock remote directory! Please investigate"))))
#+END_SRC
← This is actually rather superficial treatment; in the future we might want to treat this error better based on the information contained in =(cdr DL)=.

Otherwise we proceed in a normal way.
Finally let us print stored messages (printed by =end-log=):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(dolist (msg (reverse important-msgs)) (message msg))
(setf important-msgs nil)
(clog :info "done syncing")
(write-region (format "%s: %s -- %s
" localhost  (TS (current-time)) (format-time-string "%H:%M:%S" (current-time))) nil (history)))
ok))
#+END_SRC
=cloud-sync= ends here.

Let us =cloud-sync= before the user quits ~emacs~:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun before-exit()
;; (write-conf)
(when (cloud-sync)
  (safe-delete-dir /tmp/cloud/)))
#+END_SRC
#+begin_note
if the connection with the cloud is unstable, an attempt to access the cloud can take more than 10 seconds.
#+end_note

So don't be surprised if quitting emacs takes a long time; the reason for that might be just broken connection to the cloud.
Let it wait for about 30 seconds, and it quits without syncing.
(The waiting time might depend on your [[ssh-config][ssh-configuration]].)

* Actions
By "action" I mean a pending order issued by another host.
For example, suppose that when I yesterday worked on my laptop, I have erased or renamed a file or a directory.
Today I came to my office and I want the same file/directory to be erased/renamed on my office computer.
Yesterday my laptop issued an order to erase/rename that file/directory on every host whoose name is
enumerated in =cloud-hosts=. This order will exist untill all hosts execute it, and then it will be forgotten.

** Definitions
Acctions can be applied to both files and directories. An action is a vector.
=(i-time i-ID i-args i-hostnames i-Nargs)= are integer indices, each pointing to a field in an action:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar action-fields '(i-time i-ID i-args i-hostnames i-Nargs))
(let ((i 0)) (dolist (AF action-fields) (setf i (1+ (set AF i)))))
#+END_SRC
where =i-Nargs= is used only when parsing action lines from the remote file DB.

=(i-forget i-delete i-rename i-host-add i-host-forget i-share)= are integer IDs, each identifying some kind of action (e.g., "forget file/directory" or "delete file/directory"):
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(defvar action-IDs '(i-forget i-delete i-rename i-host-add i-host-forget i-share))
(let ((i 0)) (dolist (AI action-IDs) (setf i (1+ (set AI i)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun new-action (a-ID &rest args)
(mapcar #'(lambda(FN) (clog :debug "new-action(%d %s)" a-ID FN)) args)
  (let ((action (make-vector (length action-fields) nil)))
    (aset action i-ID a-ID)
    (aset action i-time (current-time))
    (aset action i-args args)
    (aset action i-hostnames (remove localhost cloud-hosts))
    (end-push action remote-actions)))
#+END_SRC
Later more actions will be introduced:
1. =i-reset-pass= for (gradual – not for all files at once) password renewal
2. =i-reset-names= for gradual renaming of the files in the cloud.

The function =perform= performs an action:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perform(action &optional HNs)
"performing an action locally"
(write-region
(format "%s: %s
" (TS (current-time)) (format-action action))
nil (local/log) t)
  (let ((arguments (aref action i-args)))
    (case* (aref action i-ID) =
      (i-host-forget (dolist (arg arguments) (drop cloud-hosts arg)) t)
      (i-host-add (dolist (arg arguments) (push arg cloud-hosts)) t)
      (i-forget (cloud-forget-many arguments) t)
      (i-delete (cloud-rm arguments) t)
      (i-rename (cloud-rename-file (first arguments) (second arguments)) t)
#+END_SRC
When the file(s) are finally shared among /all/ hosts (so that ~localhost~ is the last one), we just forget the file(s):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
      (i-share (when (= 1 (length HNs)) (cloud-forget-many arguments)))
      (otherwise (clog :error "unknown action %d" (aref action i-ID))))) t)
#+END_SRC

We must inform other hosts about actions they have to perform; for that we write list of actions
to the remote file DB using the function
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun format-action (action)
  (format "%S %d %d %s %s"
(full-TS (aref action i-time)); 1. Time stamp,
(aref action i-ID); 2. (integer) action ID,
(length (aref action i-args)); 3. (integer) number of arguments for this action (one column),
(apply #'concat (mapcar #'(lambda(arg) (format "%S " (tilda arg))) (aref action i-args))); 4. [arguments+] (several columns),
(apply #'concat (mapcar #'(lambda(HN) (format "%S " HN)) (aref action i-hostnames))))); 5. hostnames, where the action has to be performed (several columns).
#+END_SRC
In this block, every line is has the following fields (columns):
1. time stamp: in emacs'es single-thread world, time stamp can uniquely identify an action,
2. (integer) identifying action type,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).

Since there is no hook on renaming or deleting files, we overwrite dired functions for renaming and deleting;
their new versions will now contain standard code plus mine.

Storing standard definitions of =dired-rename-file= and =dired-delete-file= in variables ~DRF~ and ~DDF~:
#+BEGIN_SRC emacs-lisp :tangle generated/variables.el
(unless (boundp 'DRF) (defvar DRF (indirect-function (symbol-function 'dired-rename-file)) "original dired-rename-file function"))
(unless (boundp 'DDF) (defvar DDF (indirect-function (symbol-function 'dired-delete-file)) "original dired-delete-file function"))
#+END_SRC

I had to add the following block in order to avoid automatic clouding of ~.md~ files by the =org-md-export-to-markdown= function:
#+BEGIN_SRC emacs-lisp
(unless (boundp 'OEMD) (defvar OEMD (indirect-function (symbol-function 'org-md-export-to-markdown)) "original org-md-export-to-markdown function"))
(defun org-md-export-to-markdown (&optional ASYNC SUBTREEP VISIBLE-ONLY)
  (let ((FN (buffer-file-name)))
    (funcall OEMD ASYNC SUBTREEP VISIBLE-ONLY)
    (blacklist (replace-file-ext FN "md"))))
#+END_SRC
← unfortunately, I could not make this work: =(functionp 'OEMD)= evaluates to =nil=.

Now let us write code for each of the following actions:
1. =delete= (created when a user removes a file or a directory in a dired buffer),
2. =cloud-host-add= (created when this code is launched on a computer, whose name is not mentioned in =cloud-hosts=,
3. =cloud-host-forget=,
4. =cloud-add=,
5. =cloud-forget=,
4. =cloud-rename= (called when the file/directory is renamed in ~dired~).

** Delete
We ovewrite standard emacs =dired-delete-file= function:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun dired-delete-file (FN &optional dirP TRASH)
  (let ((FN (tilda FN))); ~/programming/emacs/functions.el
(when (car    
       (condition-case err (cons t (funcall DDF FN dirP TRASH))
	 (file-error (clog :error "in DDF: %s" (error-message-string err)))))
  (cons t (and (cloud-forget-recursive FN)
	       (new-action i-delete FN))))))
#+END_SRC
where ~FN~ might be a directory.

The following function is used to perform pending delete ordered by another host:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-rm (args)
(let ((ok (cloud-forget-many args)))
  (dolist (arg args)
    (setf ok (and (safe-delete-dir arg t) (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-forget-many (args)
  (interactive) 
(let ((ok t))
  (dolist (arg args)
    (setf ok (and (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

When we rename or delete a folder, we have to perform similar action on every cloud file contained inside the folder.
The following function helps us finding such files:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun contained-in(DN)
  (let* ((dir-name (tilda DN)) res (dir-name (file-name-as-directory dir-name)))
    (dolist (DB-rec file-DB)
      (when(and
(< (length dir-name) (length (aref DB-rec plain)))
(string=(substring-no-properties (aref DB-rec plain) 0 (length dir-name)) dir-name))
        (push DB-rec res)))
      res))
#+END_SRC

** Add/forget hosts
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun add-to-actions(hostname)
  (dolist (action remote-actions)
    (unless (member hostname (aref action i-hostnames))
      (aset action i-hostnames (cons hostname (aref action i-hostnames))))))
(defun erase-from-actions(hostname)
  (dolist (action remote-actions)
    (when (member hostname (aref action i-hostnames))
      (aset action i-hostnames (remove hostname (aref action i-hostnames))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-host-add ()
  "adding THIS host to the cloud sync-system"
  (unless (member localhost cloud-hosts)
    (push localhost cloud-hosts))
  (new-action i-host-add localhost)
  (add-to-actions localhost))
#+END_SRC
As of 2020-10-20 =cloud-host-forget= is untested:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-host-forget ()
  "remove host from the cloud sync-system"
    (when (yes-or-no-p (format "Forget the host %s?" localhost))
      (new-action i-host-forget localhost)
      (if (cloud-sync)
	  (safe-dired-delete (local/config))
	(clog :error "sync failed, so I will not erase local configuration"))))
#+END_SRC
** Add files
To add (or "cloud") a file I suggest opening a dired buffer, mark the files and then =M-x cloud-add=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-add(&optional FN)
(interactive)
(if FN (add-file FN)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (add-file (dired-get-filename)) nil)
(if-let ((FN (buffer-file-name))) (add-file FN)
    (unless
	(add-file (read-string "file to be clouded=" (if FN FN "")))
      (clog :error "could not cloud this file"))))))
#+END_SRC
Pending upgrades for =cloud-add=:
1. =cloud-add= must become more user-friendly: let the user know that file(s) are sucessfully clouded, and
2. =cloud-add= must work with directories. This is, however, not so straightforward because I almost never want to cloud _all_ files within a directory.

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun blacklist(FN)
(let ((FN (tilda FN)))
 (cloud-forget-file FN)
(unless (member FN *blacklist*)
 (push FN *blacklist*))))
(defun black-p(FN &optional file-rec)
(let ((result
(or
(member FN *blacklist*) (string-match "tmp" FN)
(string-match (concat ~ ".") (untilda FN))
(member (file-name-extension FN) junk-extensions)
(backup-file-name-p FN)
(when ignored-dirs (string-match(substring(apply #'concat
  (mapcar #'(lambda(d)(format "\\(^%s\\)\\|" d)) ignored-dirs)) 0 -2) FN))
(progn
  (unless file-rec (setf file-rec (get-file-properties FN)))
(when file-rec
  (or
    (member (aref file-rec gname) '("tmp"))
    (< 1000000 (aref file-rec size))))))))
(cons result file-rec)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun white-p(FN &optional file-rec)
(unless file-rec (setf file-rec (get-file-properties FN)))
(cons (member (aref file-rec gname) '("important" "keepOneYear" "keepTwoYears" "keepThreeYears")) file-rec))
#+END_SRC

In =add-file= if ~FN~ is a directory, it must end with a slash symbol:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun add-file(FN &optional file-rec)
(let ((FN (tilda (file-chase-links FN))))
(unless (cloud-locate-FN FN)
(ifn (file-directory-p FN)
  (needs ((GFP (or file-rec (get-file-properties* FN)) (clog :error "Aborting attempt to cloud inexisting file %s" FN))
          (CN (new-file-name remote-directory)))
(push FN added-files)
    (aset GFP cipher CN)
    (push GFP file-DB)
    (clog :debug "add-file/upload: %s(%s)" FN (TS(aref GFP mtime)))
    (upload GFP)
    (when (member (file-name-extension FN) '("jpeg" "png" "jpg"))
#+END_SRC
← here we assumed that files' extensions are low case; this restriction can be easilly waived.

Since we are clouding an image, we need to 
1. generate an individual password for it,
2. save this password in the "all-passwords" file whose name is given by =(image-passes)=, and
3. notify our code that "all-passwords" file was changed:
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(write-region
  (format "%s %s
" CN (rand-str 18)) nil (image-passes) t)
(touch (image-passes))))
#+END_SRC
In case when ~FN~ is a directory:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(let ((DN (file-name-as-directory FN)))
(dolist (FN (directory-files DN nil nil t))
(unless (member FN '("." ".."))
(let ((FN (concat DN FN)) FR)
#+END_SRC
where =FR= is the file record (an array containing file info)
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(if (or
(let ((r (white-p FN))) (setf FR (cdr r)) (car r))
(not
(let ((r (black-p FN FR))) (setf FR (cdr r)) (car r))))
(add-file FN FR)
(clog :debug "not auto-clouding %s" FN))))))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun auto-add-file(FN &optional file-rec)
"when the file is clouded automatically"
 (unless (car(black-p FN file-rec)) (add-file FN file-rec)) t)
#+END_SRC
← For example, when I create emails in emacs, it saves temporary files that contain "tmp" in their names, e.g.,
~/tmp/mutt-kolmogorov-1000-22758-436807635268831134~; I do not want to cloud those.

** Forget files
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-forget-file (local-FN); called *after* the file has already been sucessfully deleted
  (needs ((DB-rec (or (cloud-locate-FN local-FN) (old-cloud-locate-FN local-FN))
 (clog :warning "forget: doing nothing since %s is not clouded" local-FN))
          (CEXT (cip-ext local-FN))
	  (cloud-FN (concat (remote-directory) (aref DB-rec cipher) CEXT) (clog :error "in DB entry for %s" local-FN)))
(cancel-pending-upload local-FN)
#+END_SRC
Remove image's individual password:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(when (string= CEXT ".png")
(clog :debug "forgetting password for %s" local-FN)
  (forget-password (aref DB-rec cipher)))
#+END_SRC
Remove file from the database and erase its encrypted copy in the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(drop file-DB DB-rec)
(push local-FN removed-files)
(if (car (safe-dired-delete cloud-FN))
  (clog :info "erased %s" cloud-FN)
  (clog :warning "could not erase %s" cloud-FN))
 t))
#+END_SRC
← returns t if the file was clouded; otherwise does nothing and returns nil.

=cloud-forget-recursive= should be called *after* the file has already been sucessfully deleted:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-forget-recursive(FN)
(clog :debug "cloud-forget-recursive(%s)" FN)
(new-action i-forget FN)
(dolist (sub-FN (mapcar #'plain-name (contained-in FN)))
  (cloud-forget-file sub-FN))
(cloud-forget-file FN))
#+END_SRC

=cloud-forget= is excecuted either
1. when a file/directory is removed or
2. manually from the dired buffer
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-forget (&optional FN)
  (interactive)
(if FN (cloud-forget-recursive FN)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (cloud-forget-recursive (dired-get-filename)) nil)
(if-let ((FN (buffer-file-name))) (cloud-forget-recursive FN)
    (unless
	(cloud-forget-recursive (read-string "file to be forgotten=" (if FN FN "")))
      (clog :error "could not forget this file"))))))
#+END_SRC

** Rename
=cloud-rename-file= updates the file data base *after* the file has already been sucessfully renamed:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-rename-file(old new)
  (let ((source (cloud-locate-FN old))
        (target (cloud-locate-FN new)))
    (cond
     ((and source target); overwriting one cloud file with another one
      (dolist (property (list mtime modes gname))
            (aset target property (aref source property)))
      (drop file-DB source))
     (source (aset source plain new))
     (target (setf target (get-file-properties* new))))))
#+END_SRC

Updating =dired-rename-file= by overwriting it:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun dired-rename-file (old-FN new-FN ok-if-already-exists)
  (let (failure)
    (clog :debug "DRF")
    (condition-case err
	(funcall DRF old-FN new-FN ok-if-already-exists)
      (file-error
       (clog :error "DRF error!")
       (message "%s" (error-message-string err))
       (setf failure t)))
    (unless failure
      (clog :debug "cloud-rename-file %s --> %s" old-FN new-FN)
      (cloud-rename-file old-FN new-FN)
      (new-action i-rename old-FN new-FN)
#+END_SRC
In case we are renaming directories:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(when (file-directory-p old-FN)
  (let* ((old-dir (file-name-as-directory old-FN)) (LOD (length old-dir))
         (new-dir (file-name-as-directory new-FN)))
    (dolist (rec (contained-in old-FN))
      (let ((FN (aref rec plain)))
        (when (and (<= LOD (length FN))
	     (string= old-FN (substring FN 0 LOD)))
	  (let ((new-name (concat new-dir (substring FN LOD))))
            (cloud-rename-file FN new-name)
	    (new-action i-rename FN new-name))))))))))
#+END_SRC

The above function needs =rename-directory=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun rename-directory (old-dir new-dir)
"recursively update plain-names of clouded files due to renaming of a directory"
(when (file-directory-p old-dir)
  (let* ((old-dir (file-name-as-directory old-dir)) (LOD (length old-dir))
         (new-dir (file-name-as-directory new-dir)))
    (dolist (rec (contained-in old-dir))
      (let ((FN (aref rec plain)))
        (when (and (<= LOD (length FN))
		   (string= old-dir (substring FN 0 LOD)))
	  (aset rec plain (concat new-dir (substring FN LOD)))))))))
#+END_SRC

* Starting all this machinery
** Every time we start ~emacs~
We will update global configuration variables using
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun update-conf(conf &rest conf-params)
(clog :debug "started update-conf")
  (dolist (CP conf-params)
    (when-let ((CPV (cdr (assoc CP conf)))) (set (intern CP) CPV)))
(clog :debug "ended update-conf"))
#+END_SRC

I suggest running =(cloud-start)= from =~/.emacs= every time you restart ~emacs~ (see [[file:README.org::Quick start][README.org]]):
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun cloud-start()
(save-some-buffers)
(clog :debug "cloud-start: local/config = %s" (local/config))
(ifn-let ((conf (read-conf)))
(progn
  (clog :warning "could not read local configuration file, trying to (re)create configuration")
  (when (cloud-init)
  (clog :info "check newly created configuraion %s and then M-x cloud-start" (local/config))))
#+END_SRC
We have read configuration, and now let us check if it is correct:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(update-conf conf "remote-directory" "junk-extensions" "ignored-dirs" "remote/files" "number-of-CPU-cores" "password")
#+END_SRC
In case ~remote-directory~ configuration parameter is missing, let ask the user for the input:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(ifn remote-directory (clog :error "You have to set remote-directory for me before I can proceed")
(ifn password (clog :error "You have to set encryption password for me before I can proceed")
#+END_SRC
At this point the configuration is o.k., so we can save it when we quit eamcs:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(add-hook 'kill-emacs-hook 'before-exit)
#+END_SRC
The file with the name given by =(image-passes)= contains individual passwords used to encode images;
even if we've got no images clouded so there are no passwords for them, this file should still exist:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (file-exists-p (image-passes))
  (write-region "" nil (image-passes))
  (add-file (image-passes)))
#+END_SRC
← and it must also be clouded.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(reset-Makefile)
(cloud-sync)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun read-fileDB()
(clog :debug "starting read-fileDB")
(or
(and
;; (cloud-connected-p)
(= 0 (apply #'call-process
(append (list "gpg" nil nil nil)
(split-string (format
"--batch --yes --pinentry-mode loopback --passphrase %s -o %s --decrypt %s"
#+END_SRC
← Strange: there will be errors if I quote password by writing =--passphrase %S= instead of =--passphrase %s=!

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
password (untilda (local/all)) (remote-files))))))
(read-all (local/all)))
(clog :error "cloud-start header failed") nil))
#+END_SRC

* In case of emergency
Saving database to a file:
#+BEGIN_SRC 
(defun write-fileDB-full (DBname)
  (with-temp-file DBname
    (dolist (file-record file-DB)
          (progn (insert (format-file file-record)) (newline)))))
(write-fileDB-full "/home/shalaev/cloud.db")
#+END_SRC

#+BEGIN_SRC lisp
(setf file-DB
(loop for FR in file-DB unless
      (string-match "\\.\\./" (plain-name FR))
      collect FR))
#+END_SRC

* Packaging
(Not finished.)
#+BEGIN_SRC emacs-lisp :tangle generated/cloud-pkg.el
(define-package "cloud" "0.1" "secure cloud file synchronization" '(cl epg dired-aux)
:keywords '("cloud" "gpg" "synchronization")
:url "https://cloud.leanws.com"
:authors '(("Oleg Shalaev" . "oleg@chalaev.com"))
:maintainer '("Oleg Shalaev" . "oleg@chalaev.com"))
;; Local Variables:
;; no-byte-compile: t
;; End:
;; cloud-pkg.el ends here
#+END_SRC
