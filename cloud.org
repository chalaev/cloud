#+TITLE: emacs-based secure cloud storage for text files
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

Uses ~macros.el~, ~functions.el~, and ~logging.el~ from the [[https://notabug.org/shalaev/elisp-goodies][elisp-goodies]] project.

Github vs Emacs: since ~github~
1. does not understand ~org-mode~ internal links,
2. does not show calculation results from ~org~ files and
3. can not hide selected sections (thus making the web page too long),
consider opening this file in ~emacs~ instead of watching it online.

* Symmetric (en/de)cryption
All hosts (computers) are treated identically – there is no "main" host. This is why we use symmetric encryption
with automatically generated password. 
For (en/de)cryption, emacs will call shell commands similar to
#+BEGIN_SRC shell
gpg --pinentry-mode loopback --passphrase "somepass" -o /mnt/cloud/abc.gpg --symmetric ~/myFile.txt
gpg --pinentry-mode loopback --passphrase "somepass" -o ~/myFile.txt --decrypt /mnt/cloud/abc.gpg
#+END_SRC

* Initialization
[[https://stallman.org/][Stallman]] recomends not to use  ~CL~, but for now I am still requiring it.

The following block is only only needed if we want to evaluate ~main.el~
which, in its turn, will require and load other files:
#+BEGIN_SRC emacs-lisp :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from cloud.org
(mapcar #'require '(cl dired-aux timezone diary-lib subr-x))
(mapcar #'load-file* '("0" "macros" "functions" "logging" "1" "2"))
#+END_SRC
merge all these into ~cloud.el~ (see ~Makefile~), which is launched from =~/.emacs=.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from cloud.org
(defvar cloud-delete-contents t "if decrypted contents file must be erased")
(defvar cloud-hosts nil "host names participating in file syncronization")
(defvar cloud-actions nil "actions to be saved in the cloud")
(defvar removed-files  nil "files that were just removed (or renamed) on local host before (cloud-sync)")
(defvar important-msgs nil "these messages will be typically printed at the end of the process")
(defvar gpg-process nil "assyncronous make-process for (en/de)cryption")
#+END_SRC

=cloud-file-hooks= is used for special files (e.g., diary or bookmarks);
When those are copied from the cloud to the local hard drive, one should call, e.g., =diary-view-entries= or =bookmark-load=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar N-CPU-cores 1)
(defvar cloud-dir  "/mnt/cloud/")
(defvar cloud-file-hooks nil "for special files treatment")
(defvar ~ (getenv "HOME"))
(defvar emacs-d (concat ~ "/.emacs.d/"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun local-dir() (tilda (concat emacs-d "cloud/")))
(defun cloud-mk() (concat (local-dir) "cloud.mk"))
(defun cloud-lockdir() (concat cloud-dir "now-syncing/"))
(defun cloud-lockfile() (concat (cloud-lockdir) (system-name)))
(defun all-passes() (concat (local-dir) "individual.passes"))
#+END_SRC

Instead of storing configuration in =~/.emacs= I prefer to store it in a separate file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun local-config() (concat (local-dir) "config"))
#+END_SRC
This is because
1. sometimes the code will update its configuration, and
2. in this way configuration data is more separated from other ~elisp~ programs.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar contents-name nil)
#+END_SRC
– this is the default value, just in case it is not stored in the configuration file.

=file-DB= is a list of vectors; each vector corresponds to a clouded file.
Every time we =M-x cloud-sync=, =file-DB= gets synchronized with the cloud through the function =write-fileDB= (see below).
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar file-DB nil "")
(defvar password nil); to be read from config or generated
(defvar DB-fields; indices numerating array fields
(list 'plain; original (local) file name
'cipher; encrypted file name (base name)
'mtime; modification time
'modes; permissions
'uname; user name (obsolete and unused)
'gname; group name
))
(let ((i 0)) (dolist (field-name DB-fields) (setf i (1+ (set field-name i)))))
#+END_SRC

** (En/De)cryption
Especially when ~(= 0 *log-level*)~ this code might print many log messages.
For most important ones I will use this function
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun end-log (fstr &rest args)
  "message + time"
  (push
   (apply #'format
	  (cons (concat
		 (format-time-string "%H:%M:%S " (apply 'encode-time (butlast (decode-time (current-time)) 3)))
		 fstr)
		args))
   important-msgs))
#+END_SRC
which is going to print them at the end of the syncronization session.

Some files require special treatment after they are updated on the local disk from the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun post-decrypt (FN)
  "special treatment for certain files"
  (let ((ext (file-name-extension FN))
	(name (file-name-base FN)))
    (when (string= FN (expand-file-name diary-file))
      (with-current-buffer (find-file-noselect (diary-check-diary-file))
	(clog :info "diary buffer opened or updated")))
     (when (member FN *loaded*)
       (end-log "*configuration changed, consider reloading emacs*")
    (clog :warning "consider reloading configuration file %s" FN)
    ;;   (load-file FN))
)))
#+END_SRC
where =diary-check-diary-file= will raise an error (exception) in case of inexisting diary-file.

* Connection with the cloud
We proceed with =cloud-sync= command only if the internet connection is established, which is checked by
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-connected-p()
  (and
   cloud-dir contents-name
   (file-readable-p cloud-dir)))
;;(file-readable-p (concat cloud-dir contents-name ".gpg")
#+END_SRC
← note that =cloud-connected-p= should *not* be called before local file has been read by =read-conf=.

** SSH
Sometimes internet connection can be unstable or shut down unexpectedly,
so I added ~reconnect~ option to the ~/etc/fstab~ entry
(this probably will not work if you have to supply password to unlock the ssh key):
#+BEGIN_SRC 
# /etc/fstab
sshfs#shalaev@leanws.com: /mnt/lws fuse reconnect,users,auto 0 0
#+END_SRC
where "shalaev" is my user name, and ~leanws.com~ is the ssh-server (replace these with your values).

To limit the timeout to 30 seconds, update =~/.ssh/config= as follows:
#+name: ssh-config
#+BEGIN_SRC
# ~/.ssh/config
ServerAliveInterval 15
ServerAliveCountMax 2
#+END_SRC

** WebDav
=WebDav= is much slower than =ssh=, but it should be ok for file synchronization.
To mount ~yandex~ or ~pcloud~ to local directories ~/mnt/yd/~ and ~/mnt/pc~ I need three files:
~/etc/fstab~, ~/etc/davfs2/davfs2.conf~, and ~/etc/davfs2/secrets~
#+BEGIN_SRC 
# /etc/fstab
https://webdav.yandex.ru        /mnt/yd	davfs   user,noauto,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
https://webdav.pcloud.com	/mnt/pc	davfs	user,noauto,uid=shalaev,gid=shalaev,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
#+END_SRC
where ~shalaev~ is my user name and group name; you must replace it with yours.

#+BEGIN_SRC
# /etc/davfs2/davfs2.conf
dav_user        davfs2
dav_group       davfs2
use_locks	0
cache_dir       /var/cache/davfs2 # system wide cache
cache_size      5000              # MiByte
delay_upload	0
#+END_SRC

#+BEGIN_SRC
# /etc/davfs2/secrets
/mnt/yd	myYandexLogin		password
/mnt/pc	myPCloudLogin		password
#+END_SRC

** FTP
Somehow I am not aware of /reliable/ way of mounting an ~ftp~ server to a directory in linux;
~emacs~ also seems to be bad in estsblishing ~ftp~ connections.
May be developers think that ~ftp~ is obsolete and ignore it;
personally I don't see anything wrong with it, especially when an ~ftp~ connection is established using SSL-encryption.

Probably the best way to improve FTP-support in emacs would be to write an eLisp-wrapper for [[http://lftp.yar.ru][lftp]] command.

* Contents file
Contents file is the main one in the cloud; it contains information
(name, group, modification time) about all clouded files.
** Creation
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun write-conf()
(with-temp-file (local-config)
  (insert (format "delete-contents=%s" (if cloud-delete-contents "yes" "no"))) (newline)
  (insert (format "contents-name=%s" contents-name)) (newline)
  (insert (format "password=%s" password)) (newline)
  (insert (format "number-of-CPU-cores=%s" N-CPU-cores)) (newline)
  (insert (format "cloud-directory=%s" cloud-dir)) (newline)))
#+END_SRC

Before we start for the very first time, when cloud directory is inexistent or empty, 
we create the password for encryption by =(cloud-init)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-init() "initializes cloud directory and generates password -- runs only once"
(interactive)
(when (yes-or-no-p "Is cloud mounted?")
(setf cloud-dir (read-string "cloud directory=" cloud-dir))
(ifn (member (safe-mkdir cloud-dir) '(:exists t))
(clog :error "could not create/access directory %s" cloud-dir)
#+END_SRC
For safety reasons refusing to initialize a directory already containing encrypted files:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(if (directory-files cloud-dir nil "^.\+.gpg$" t)
    (clog :error "please clean the directory %s before asking me to initialize it" cloud-dir)
(clog :info "creating (main) contents file in unused directory %s" cloud-dir)
(ifn-set ((contents-name (new-file-name cloud-dir)))
  (clog :error "could not create DB file in the directory %s" cloud-dir)
#+END_SRC
Generating random password and saving it in the local configuration file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(setf password (rand-str 9))
#+END_SRC
– one password for everything – 
for now this software is designed for single person only, and I do not see why should I use individual passwords for different files.
This might be changed later if I ever upgrade the code for sharing files within a group of people;
but if this happens, I will probably have to abandon symmetric encryption and deal with public/private keys.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (member (safe-mkdir (local-dir)) '(:exists t))
(clog :error "could not create/acess directory %s" (local-dir))
(write-conf)
(clog :info "use M-x cloud-add in the dired to cloud important files and directories" )))))))
#+END_SRC
** Writing contents file and understanding its format.
*** The first line: list of all hostnames without quotes, separated by spaces.
In the following, ~DBname~ is the name of _decrypted_ contents file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun write-fileDB (DBname)
  (with-temp-file DBname
(dolist (hostname cloud-hosts) (insert (format "%s " hostname)))
(delete-char -1) (newline)
#+END_SRC
The next several lines contain information about pending [[Actions][actions]].
*** Pending actions
In this block, every line is has the following fields (columns):
1. Time stamp,
2. (integer) action ID,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).
   Gets updated by =cloud-host-add= and =cloud-host-forget=.

The order of actions is important! For example, imagine that
I renamed or moved a file twice; the order of these actions on a remote host should be the as on the local one:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (action (reverse cloud-actions))
  (insert (format-action action)) (drop cloud-actions action) (delete-char -1) (newline))
#+END_SRC
Pending actions block is ended by an empty line separating it from the rest of the file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(newline)
#+END_SRC
*** List of clouded files
This is the last and the largest block of lines.
Here every line corresponds to one file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (file-record file-DB)
  (insert (format-file file-record)) (newline))
(setf removed-files nil)))
#+END_SRC
** Reading and parsing
*** list of host names
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun clouded(DB-rec)
(let ((FN (aref DB-rec plain))
      (CN (aref DB-rec cipher)))
  (concat cloud-dir CN (cip-ext FN))))
#+END_SRC
Below we define =read-fileDB*= intended for reading (previously decrypted) configuration file
during the start of this code. =read-fileDB*= always returns =nil=.
(Try to optimize =read-fileDB*= because for 280 files it takes up to 5 seconds which is annoying.)
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-fileDB* (DBname)
  "reads content (text) file into the database file-DB"
(clog :debug "started read-fileDB*")
  (find-file DBname) (goto-char (point-min))
(macrolet ((read-line() '(setf str (buffer-substring-no-properties (point) (line-end-position)))))
  (let ((BN (buffer-name)) str)
(needs-set
 ((cloud-hosts 
  (split-string (read-line))
  (clog :error "invalid first line in the contents file %s" DBname)))
#+END_SRC
In case =read-fileDB*= is launched on an unknown computer
(that is, its hostname is not yet mentioned in the first line of the file =DBname=),
it is automatically added to the cloud network:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (member (system-name) cloud-hosts) (cloud-host-add))
(forward-line)
#+END_SRC
*** list of pending actions
The concept of actions is explained in the [[Actions][corresponding section]].

Keep reading one action after another until we encounter an empty line:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(while (< 0 (length (read-line)))
(clog :info "action %s ..." str)
(let ((action (make-vector (length action-fields) nil)))
#+END_SRC
An action string has unknown number of fields (columns); some of them are quoted and may contain spaces, others are not.
We use =begins-with= from ~common.el~ to read the fields.

Let us parse the string =str= and save extracted parameters (values) in the vector =action=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (column (list
                 `(:time-stamp . ,i-time)
                 `(:int . ,i-ID)
                 `(:int . ,i-Nargs)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
=(aref action i-Nargs)= must be evaluated _after_ =`(:int . ,i-Nargs)=, but _before_ we proceed with =(cons (cons  :string  (aref action i-Nargs)) i-args)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (column (list
                 (cons (cons  :string  (aref action i-Nargs)) i-args)
                 `(:strings . ,i-hostnames)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value)); was (mapcar #'untilda (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
So, we have just got information about pending action.
We perform it immediately if our hostname is in the list =(aref action i-hostnames)=.

In this sigle-user code action's time stamp =AID= may serve as its unique ID:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let ((AID (format-time-string "%02m/%02d %H:%M:%S" (aref action i-time))))
(clog :info "... will later be referenced as %s" AID)
  (ifn (member (system-name) (aref action i-hostnames))
      (clog :info "this host is unaffected by action %s" AID)
    (when (perform action)
	(clog :debug "sucessfully performed action %s" AID)
      (clog :error " action %s failed, will NOT retry it" AID))
#+END_SRC
← even if the action failed, we wash our hands and not retry it.
If the action is still pending on some hosts, we will store it in =cloud-actions=
which is going later to be saved into the [[Contents file][contents file]]:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when (drop (aref action i-hostnames) (system-name))
  (push action cloud-actions)))))
  (forward-line))
#+END_SRC
where the last =(forward-line)= moved the pointer (cursor)
either to the next action line or to an empty line.

An empty line ends the action reading loop;
the next thing to do is to read/parse the files' block of lines.

*** list of (clouded) files
For files that need to be (up/down)loaded (to/from) the cloud =(read-fileDB)= forms ~cloud.mk~
which can be fed to GNU make as =make --jobs=4 -f cloud.mk=, where ~jobs~ parameter is the (configurable) number of CPU cores.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(forward-line)
(needs ((CDFs (mapcar #'(lambda(s) (replace-regexp-in-string "....$" "" s))
      (directory-files cloud-dir nil "...\...." t)) (clog :error "can not read %s" cloud-dir)))
(while (< 10 (length (read-line)))
(when-let ((CF (str-to-DBrec str)))
#+END_SRC
Ideally if =file-DB= contains a file, it must exist on a local hard disk.
In reality either file, the local one, or remote one, or both, might be absent,
and we have to adress such situation:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let* ((FN (plain-name CF))
      (remote-exists (member FN CDFs))
      (local-exists (or (cloud-locate-FN FN)
(when-let ((LF (get-file-properties FN)))
        (aset LF cipher (aref CF cipher))
        (push LF file-DB)
        LF))))
(cond
((not (or local-exists remote-exists))
 (clog :error "forgetting file %s which is marked as clouded but is neither on local disk nor in the cloud" FN)
 (drop file-DB CF))
((or
 (and (not local-exists) remote-exists)
 (and local-exists remote-exists (time< (aref local-exists mtime) (aref CF mtime))))
(download CF))
((or
 (and local-exists remote-exists (time< (aref CF mtime) (aref local-exists mtime)))
 (and local-exists (not remote-exists)))
(upload CF)))))
#+END_SRC
Done with this file, moving to another one:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(forward-line))
#+END_SRC
We ended up parsing the list of files
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(save-Makefile) (kill-buffer BN))))))
#+END_SRC
=(defun read-fileDB* ...)= ends here.

* On saving files in emacs
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defmacro bad-column (cType N &optional str)
(if str
`(clog :error "invalid %dth column in %s line = %s" ,N ,cType ,str)
`(clog :error "invalid %dth column in %s line" ,N ,cType)))
#+END_SRC
When the file is saved in emacs (=C-x s=), we mark it so that it is going
to be uploaded to the cloud when the user calls =cloud-sync= next time:

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun touch (FN)
"called when the file named FN is changed"
(when (and FN (stringp FN))
  (when-let ((file-data (cloud-locate-FN FN)))
    (aset file-data mtime (current-time))
    (upload file-data))))
(defun on-current-buffer-save()
  (touch (file-chase-links (buffer-file-name))))
(add-hook 'after-save-hook 'on-current-buffer-save)
#+END_SRC
* Parsing file line
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun str-to-DBrec(str)
"parses one file line from the contents file"
(ifn (string-match "\"\\(.+\\)\"\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([[:digit:]]+\\)\s+\"\\(.+\\)\"" str)
(clog :error "Ignoring invalid file line %s" str)
#+END_SRC
We've got a valid string describing a clouded file, now let us parse it.
The first column is the file name:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let ((CF (make-vector (length DB-fields) nil))
      (FN (match-string 1 str)))
  (aset CF plain FN)
  (aset CF cipher (match-string 2 str))
  (aset CF uname (match-string 3 str))
#+END_SRC
← actually the last field (=uname= stands for "user name") is obsolete and no more used: it is assumed that all files are owned by the user who runs the code.
(Later I will get rid of this field or replace it with another one.)

We syncronize ~gname~ (name of the group), ~modes~ (permissions), and ~mtime~ (modification time) for every file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
  (aset CF gname (match-string 4 str))
  (aset CF modes (string-to-number (match-string 5 str)))
  (let ((mtime-str (match-string 6 str)))
(ifn (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [[:upper:]]\\{3\\}" mtime-str)
(bad-column "file" 6 mtime-str)
(aset CF mtime (parse-time mtime-str))
CF)))))
#+END_SRC

* Creating make file
Make file is useful because
1. it allows us to use multi-threading and
2. it simplifies debugging.

When the make file is ready, we launch it with =make -jN ~/.emacs.d/cloud/cloud.mk=, where =N= is the number of CPU cores. 
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(macrolet ((NL () '(push "
" Makefile))
(inl (&rest format-pars) `(progn (push ,(cons 'format format-pars) Makefile) (NL))))
(cl-flet ((pass-d()  (concat (local-dir) "pass.d/")))
(cl-flet ((updated() (concat (pass-d) "updated"))
       (local-log() (concat (local-dir) (system-name) ".log")))
(let (all Makefile
#+END_SRC
(Already encrypted) gpg-files types are not supposed to be encrypted, and images should be encrypted in a special way.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(specially-encoded '(
#+END_SRC
Already encrypted (~gpg~) files are just copied
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
("$(cloud)%s.gpg: %s
\tcp $< $@" "gpg")
#+END_SRC
← this format string requires 2 arguments: =(aref file-record cipher)= and =(aref file-record plain)=.

Make stanza for encrypting an image is more sophisticated:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
("$(cloud)%s.png: %s %s
\tconvert $< -encipher %s%s $@
" "jpg" "jpeg" "png")))
#+END_SRC
← this format string requires 5 arguments:
=(aref file-record cipher)=, =(aref file-record plain)=, =(updated)=,
=(pass-d)=, and (once again) =(aref file-record cipher)=.

Similarly, for decoding
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(specially-decoded '(
("%s: $(cloud)%s.gpg
\tcp $< $@" "gpg")
("%s: $(cloud)%s.png  %s
\tconvert $< -decipher %s%s $@
" "jpg" "jpeg" "png"))))
#+END_SRC
with the same number of arguments, as for encoding above.

** Creating ~make~ stanza for encoding one file
Non-standard case (an image or a ~gpg~-file):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(cl-flet ((enc-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-encoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr XYZ FN (updated) (pass-d) XYZ)
#+END_SRC
where ~XYZ~ is the (random) 3-symbol cloud name of the file (without extension).

All other files are treated with ~gpg~:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(format "$(cloud)%s.gpg: %s
\t@$(enc) $@ $<
" XYZ FN))
#+END_SRC
At the end of every file (en/de)coding stanza we send a message to the log file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(format "\t-echo \"$(date): uploaded %s\" >> $(localLog)
" FN)))))
#+END_SRC
Here ends the function =enc-make-stanza= that produces make-stanza for encoding.

The decoding is similar:
** Creating ~make~ stanza for decoding one file
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dec-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-decoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr FN XYZ (updated) (pass-d) XYZ)
(format "%s: $(cloud)%s.gpg
\t@$(dec) $@ $<
" FN XYZ ))
(format "\t-chgrp %s $@
\t-chmod %o $@
\t-touch --date=%S $@
\t-echo \"$(date): downloaded %s\" >> $(localLog)
" (aref file-record gname) (aref file-record modes) (full-TS (aref file-record mtime)) FN))))))
#+END_SRC

** Putting this all together
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun download (file-record)
(needs (
(FN (aref file-record plain) (clog :error "download: file lacks plain name"))
(stanza (dec-make-stanza file-record) (clog :error "download: could not create stanza for %s" FN)))
(push (format " %s" FN) all)
(push stanza Makefile) (NL)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun upload (file-record)
(needs ((FN (tilda (aref file-record plain)) (clog :error "upload: file lacks plain name"))
	(CN (aref file-record cipher) (clog :error "upload: file %s lacks cipher name" FN))
	(stanza (enc-make-stanza file-record) (clog :error "upload: could not create stanza for %s" FN)))
(push (format " %s" (concat cloud-dir CN
(cip-ext FN)))
all)
(push stanza Makefile) (NL)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun reset-Makefile()
"reseting make file"
(when (or (and (file-exists-p (pass-d)) (file-directory-p (pass-d))) (safe-mkdir (pass-d)))
(setf all nil Makefile nil)
(inl "cloud=%s" cloud-dir)
(inl "password=%S" password)
(inl "gpg=gpg --pinentry-mode loopback --batch --yes")
(inl "enc=$(gpg) --symmetric --passphrase $(password) -o")
(inl "dec=$(gpg) --decrypt   --passphrase $(password) -o")
(inl "localLog=%s" (local-log))
(inl "MK=%s" (cloud-mk))
(inl "date=`date '+%%m/%%d %%T'`
")
(inl (concat (format "%s: %s
\tawk '{print $$2 > %S$$1}' $<
\techo $(date) > $@
\t-chgrp -R tmp %s*
" (updated) (all-passes) (untilda (pass-d)) (pass-d))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun save-Makefile()
"flushing make file"
(inl "all:%s
\techo \"background (en/de)cryption on %s finished $(date)\" >> %s
\t-rm %s
\t-rmdir %s
\t-emacsclient -e '(reset-Makefile)'
"
(apply #'concat all)
(system-name)
(concat cloud-dir "history")
(cloud-lockfile) (cloud-lockdir))
(write-region (apply #'concat (reverse Makefile)) nil (cloud-mk))))))))
#+END_SRC

* cloud-sync
=cloud-sync= is the most frequently used function.

We assume that files are changed only within emacs, so that
=file-DB= always contains the most recent information about clouded files.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-sync()
(interactive)
(ifn (cloud-connected-p)
  (clog :error "remote directory is not mounted")
(let ((time-stamp (TS (current-time)))
      (mkdir (safe-mkdir (cloud-lockdir))) (ok t))
  (if (member mkdir '(:permission nil))
      (clog :error "cannot cloud-sync without %s" (cloud-lockdir))
(clog :debug "cloud-sync started")
  (cond
   ((not mkdir) (clog :error "can not create lock directory %s. Is the remote directory monted?" (cloud-lockdir)))
   ((member mkdir '(:exists))
    (clog :error "lock directory %s exists; someone else might be syncing right now. If this is not the case, remove %s manually" (cloud-lockdir) (cloud-lockdir)))
   ((and gpg-process (process-live-p gpg-process))
    (clog :error "I will not start new (en/de) coding process because the previous one is still funning"))
(t
(write-region time-stamp nil (cloud-lockfile))
#+END_SRC
Now let us reveal what host made the latest update to the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let* ((DN (concat cloud-dir "hosts/"))
       (FN (concat DN (system-name))))
(ifn (safe-mkdir DN) (clog :error "can not create directory %s" DN)
(unless 
(and
  (file-exists-p FN)
  (string= FN (car (sort (mapcar #'(lambda(fn) (concat DN fn)) cloud-hosts) #'file-newer-than-file-p))))
#+END_SRC
If another host has updated the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (read-fileDB)
(setf ok (clog :error "cloud-sync: could not read content file from the cloud"))
(write-region time-stamp nil (concat cloud-dir  "hosts/" (system-name)))))
#+END_SRC
← this =write-region= provides log files with time stamps to Forces of Darkness;
may be I will just ~touch~ the file without writing timestamps to it – when the code finally becomes stable.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when ok (clog :info "started syncing")
(if (and gpg-process (process-live-p gpg-process))
(clog :error "I will not start new (en/de) coding process because the previous one is still funning")
(setf gpg-process (apply #'start-process (append (list
"cloud-batch"
(generate-new-buffer "*cloud-batch*")
"make")
(split-string (format "-j%d -f %s all" N-CPU-cores (cloud-mk)))))))
#+END_SRC

*The following won't work because we don't have any sort of callbeck function being lauched at the end of make process*
– this can actually be circumvented: I can insert =emacsclient -e "(call-back)"= at the end of [[Creating make file][make file]].
#+BEGIN_SRC emacs-lisp
(needs ((hooks (assoc (plain-name FD) cloud-file-hooks)))
(dolist (hook hooks) (funcall (cdr hook) (car hook))))
#+END_SRC
← Hooks are not ready for now, but we need them because certain files indeed require special treatment.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let ((tmp-CCN (untilda (concat (local-dir) "CCN"))))
(write-fileDB tmp-CCN)
(ifn (= 0 (apply #'call-process
(append (list "gpg" nil nil nil)
(split-string (format
"--batch --yes --pinentry-mode loopback --passphrase %s  -o %s --symmetric %s"
password (concat cloud-dir contents-name ".gpg") tmp-CCN)))))
(clog :error "failed to encrypt content file %s to %s!" tmp-CCN contents-name)
(when cloud-delete-contents (safe-dired-delete tmp-CCN))
#+END_SRC
Finally let us print stored messages (printed by =end-log=):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (msg (reverse important-msgs)) (message msg))
(setf important-msgs nil)
(clog :info "done syncing")
     (write-region (format "%s: %s -- %s
" (system-name) time-stamp (format-time-string "%H:%M:%S" (current-time))) nil (concat cloud-dir "history") t)
ok)))))))))))
#+END_SRC
=cloud-sync= ends here.

This will be a hook on quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun before-exit()
  (write-conf)
  (cloud-sync))
#+END_SRC
so that =cloud-sync= is set to run before the user quits ~emacs~.
Note: if the connection with the cloud is unstable, an attempt to access the cloud can take more than 10 seconds.

So don't be surprised if quitting emacs takes a long time; the reason for that might be just broken connection to the cloud.
Let it wait for about 30 seconds, and it quits without syncing.
(The waiting time might depend on your [[ssh-config][ssh-configuration]].)

* Actions
By "action" I mean a pending order issued by another host.
For example, suppose that when I yesterday worked on my laptop, I have erased or renamed a file or a directory.
Today I came to my office and I want the same file/directory to be erased/renamed on my office computer.
Yesterday my laptop issued an order to erase/rename that file/directory on every host whoose name is
enumerated in =cloud-hosts=. This order will exist untill all hosts execute it, and then it will be forgotten.

** Definitions
Acctions can be applied to both files and directories. An action is a vector.
=(i-time i-ID i-args i-hostnames i-Nargs)= are integer indices, each pointing to a field in an action:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar action-fields '(i-time i-ID i-args i-hostnames i-Nargs))
(let ((i 0)) (dolist (AF action-fields) (setf i (1+ (set AF i)))))
#+END_SRC
where =i-Nargs= is used only when parsing action lines from the contents file.

=(i-forget i-delete i-rename i-host-add i-host-forget)= are integer IDs, each identifying some kind of action (e.g., "forget file/directory" or "delete file/directory"):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar action-IDs '(i-forget i-delete i-rename i-host-add i-host-forget))
(let ((i 0)) (dolist (AI action-IDs) (setf i (1+ (set AI i)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun new-action (a-ID &rest args)
  (let ((action (make-vector (length action-fields) nil)))
    (aset action i-ID a-ID)
    (aset action i-time (current-time))
    (aset action i-args args)
    (aset action i-hostnames (remove (system-name) cloud-hosts))
    (push action cloud-actions)))
#+END_SRC
Later more actions will be introduced:
1. =i-reset-pass= for (gradual – not for all files at once) password renewal
2. =i-reset-names= for gradual renaming of the files in the cloud.

The function =perform= performs an action:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun perform(action)
(write-region
(format "%s: %s
" (TS (current-time)) (format-action action))
nil (local-log) t)
  (let ((arguments (aref action i-args)))
    (case= (aref action i-ID)
      (i-host-forget (dolist (arg arguments) (drop cloud-hosts arg)) t)
      (i-host-add (dolist (arg arguments) (push arg cloud-hosts)) t)
      (i-forget (cloud-forget-many arguments) t)
      (i-delete (cloud-rm arguments) t)
      (i-rename (cloud-rename-file (first arguments) (second arguments)) t)
      (otherwise (clog :error "unknown action %d" (aref action i-ID)))))
   (drop cloud-actions action) t)
#+END_SRC

We must inform other hosts about actions they have to perform; for that we write list of actions
to the contents file using the function
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun format-action (action)
  (format "%S %d %d %s %s"
(full-TS (aref action i-time)); 1. Time stamp,
(aref action i-ID); 2. (integer) action ID,
(length (aref action i-args)); 3. (integer) number of arguments for this action (one column),
(apply #'concat (mapcar #'(lambda(arg) (format "%S " (tilda arg))) (aref action i-args))); 4. [arguments+] (several columns),
(apply #'concat (mapcar #'(lambda(HN) (format "%S " HN)) (aref action i-hostnames))))); 5. hostnames, where the action has to be performed (several columns).
#+END_SRC
In this block, every line is has the following fields (columns):
1. time stamp: in emacs'es single-thread world, time stamp can uniquely identify an action,
2. (integer) identifying action type,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).

Since there is no hook on renaming or deleting files, we overwrite dired functions for renaming and deleting;
their new versions will now contain standard code plus mine.

Storing standard definitions of =dired-rename-file= and =dired-delete-file= in variables ~DRF~ and ~DDF~:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (boundp 'DRF) (defvar DRF (indirect-function (symbol-function 'dired-rename-file)) "original dired-rename-file function"))
(unless (boundp 'DDF) (defvar DDF (indirect-function (symbol-function 'dired-delete-file)) "original dired-delete-file function"))
#+END_SRC

Now let us write code for each of the following actions:
1. =delete= (created when a user removes a file or a directory in a dired buffer),
2. =cloud-host-add= (created when this code is launched on a computer, whose name is not mentioned in =cloud-hosts=,
3. =cloud-host-forget=,
4. =cloud-add=,
5. =cloud-forget=,
4. =cloud-rename= (called when the file/directory is renamed in ~dired~).

** Delete
We ovewrite standard emacs =dired-delete-file= function:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun dired-delete-file (FN &optional dirP TRASH)
  (let (failure (FN (tilda FN)))
#+END_SRC
Note that ~FN~ might be a directory.

IMHO, when ~FN~ is a directory, ~RECURSIVE~ (denoted by ~dirP~ here) must always be t!
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(condition-case err (funcall DDF FN dirP TRASH)
  (file-error
    (clog :error "in DDF: %s" (error-message-string err))
    (setf failure t)))
(unless failure
#+END_SRC
=file-DB= does *not* contain any directories, so if =FN= is a directory, the following block will do nothing:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(cloud-forget-recursive FN) (new-action i-delete FN)
(when dirP
  (dolist (sub-FN (mapcar #'plain-name (contained-in FN)))
    (when (cloud-forget-file sub-FN) (new-action i-delete sub-FN)))))))
#+END_SRC

The following function is used to perform pending delete ordered by another host:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-rm (args)
  (interactive) 
(let ((ok (cloud-forget-many args)))
  (dolist (arg args)
    (setf ok (and (safe-dired-delete arg) (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-many (args)
  (interactive) 
(let ((ok t))
  (dolist (arg args)
    (setf ok (and (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

When we rename or delete a folder, we have to perform similar action on every cloud file contained inside the folder.
The following function helps us finding such files:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun contained-in(dir-name); dir-name must end with a slash /
    (let (res)
      (dolist (DB-rec file-DB)
	(when(and
(< (length dir-name) (length (aref DB-rec plain)))
(string=(substring-no-properties (aref DB-rec plain) 0 (length dir-name)) dir-name))
	  (push DB-rec res)))
      res))
#+END_SRC

** Add/forget hosts
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun add-to-actions(hostname)
  (dolist (action cloud-actions)
    (unless (member hostname (aref action i-hostnames))
      (aset action i-hostnames (cons hostname (aref action i-hostnames))))))
(defun erase-from-actions(hostname)
  (dolist (action cloud-actions)
    (when (member hostname (aref action i-hostnames))
      (aset action i-hostnames (remove hostname (aref action i-hostnames))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-host-add ()
  "adding THIS host to the cloud sync-system"
(let ((hostname (system-name)))
  (unless (member hostname cloud-hosts)
    (push hostname cloud-hosts))
  (new-action i-host-add hostname)
  (add-to-actions hostname)))
#+END_SRC
As of 2020-10-20 =cloud-host-forget= is untested:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-host-forget ()
  "remove host from the cloud sync-system"
  (let ((hostname (system-name)))
    (when (yes-or-no-p (format "Forget the host %s?" hostname))
      (new-action i-host-forget hostname)
      (if (cloud-sync)
	  (safe-dired-delete (local-config))
	(clog :error "sync failed, so I will not erase local configuration")))))
#+END_SRC
** Add files
To add (or "cloud") a file I suggest opening a dired buffer, mark the files and then =M-x cloud-add=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-add (&optional FN)
  (interactive)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (add-files (dired-get-filename)) nil)
    (unless
	(add-files (read-string "file to be clouded=" (if FN FN "")))
      (clog :error "could not cloud this file"))))
#+END_SRC
Pending upgrades for =cloud-add=:
1. =cloud-add= must become more user-friendly: let the user know that file(s) are sucessfully clouded, and
2. =cloud-add= must work with directories. This is, however not so straightforward because I almost never want to cloud _all_ files within a directory.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun add-files(&rest names)
  (let ((ok t))
    (dolist (FN names)
      (clog :debug "add-files(%s)" FN)
      (unless (cloud-locate-FN FN)
	(needs ((GFP (get-file-properties FN) (clog :error "Invalid attempt to cloud inexisting file %s" FN))
		(CN (new-file-name cloud-dir)))
	       (aset GFP cipher CN)
	       (setf ok (and ok GFP))
	       (push GFP file-DB)
(when (member (file-name-extension FN) '("jpeg" "png" "jpg"))
#+END_SRC
Since we are clouding an image, we need to 
1. generate an individual password for it,
2. save this password in the "all-passwords" file whose name is given by =(all-passes)=, and
3. notify our code that "all-passwords" file was changed:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(write-region
(format "%s %s
" CN (rand-str 18)) nil (all-passes) t)
(touch (all-passes)) ;(touch FN)
)
(upload GFP))))
    ok))
#+END_SRC


** Forget files
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-file (local-FN); called *after* the file has already been sucessfully deleted
   (push local-FN removed-files)
  (needs ((DB-rec (cloud-locate-FN local-FN) (clog :info "forget: doing nothing since %s is not clouded" local-FN))
          (CEXT (cip-ext local-FN))
	  (cloud-FN (concat cloud-dir (aref DB-rec cipher) CEXT) (clog :error "in DB entry for %s" local-FN)))
#+END_SRC
Remove image's individual password:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when (string= CEXT ".png")
(clog :debug "forgetting password for %s" local-FN)
  (forget-password (aref DB-rec cipher)))
#+END_SRC
Remove file from the database and erase its encrypted copy in the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(drop file-DB DB-rec)
(push local-FN removed-files)
(safe-dired-delete cloud-FN)
 t))
#+END_SRC
← returns t if the file was clouded; otherwise does nothing and returns nil.

=cloud-forget-recursive= should be called *after* the file has already been sucessfully deleted:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-recursive(FN)
(dolist (sub-FN (mapcar #'plain-name (contained-in FN)))
(cloud-forget-file sub-FN)))
#+END_SRC

=cloud-forget= is excecuted either
1. when a file/directory is removed or
2. manually from the dired buffer
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget (&optional FN)
  (interactive)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (cloud-forget-recursive (dired-get-filename)) nil)
    (unless
	(cloud-forget-recursive (read-string "file to be forgotten=" (if FN FN "")))
      (clog :error "could not forget this file"))))
#+END_SRC

** Rename
=cloud-rename-file= updates the file data base *after* the file has already been sucessfully renamed:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-rename-file (old new)
  (let ((source (cloud-locate-FN old))
        (target (cloud-locate-FN new)))
(cloud-forget-recursive old)
    (cond
     ((and source target); overwriting one cloud file with another one
      (dolist (property (list mtime modes uname gname)) do
            (aset target property (aref source property)))
      (drop file-DB source))
     (source (aset source plain new))
     (target (setf target (get-file-properties new))))))
#+END_SRC

Updating =dired-rename-file= by overwriting it:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun dired-rename-file (old-FN new-FN ok-if-already-exists)
  (let (failure)
    (clog :debug "DRF")
    (condition-case err
	(funcall DRF old-FN new-FN ok-if-already-exists)
      (file-error
       (clog :debug "DRF error!")
       (message "%s" (error-message-string err))
       (setf failure t)))
    (unless failure
      (clog :debug "launching my cloud rename %s --> %s" old-FN new-FN)
      (cloud-rename-file old-FN new-FN)
      (new-action i-rename old-FN new-FN))))
#+END_SRC

* Starting all this machinery
I suggest running =(cloud-start)= from =~/.emacs= every time you restart ~emacs~ (see [[file:README.org::Quick start][README.org]]):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-start()
  (interactive) (save-some-buffers)
(clog :debug "cloud-start: local-config = %s" (local-config))
(ifn-let ((conf (read-conf (local-config))))
	 (progn
	   (clog :warning "could not read local configuration file, trying to (re)create configuration")
	   (cloud-init)
	   (clog :info "check newly created configuraion %s and then M-x cloud-start" (local-config)))
#+END_SRC
We have read configuration, and now let us check if it is correct:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (and
      (if-let ((CD (cdr (assoc "cloud-directory" conf))))
	  (setf cloud-dir CD); "/mnt/lws/cloud/"
	(setf cloud-dir (read-string "cloud directory=" cloud-dir))
	(write-conf) t)
      (progn
	(when-let ((delete-contents (cdr (assoc "delete-contents" conf))))
          (setf cloud-delete-contents (if (string= "no" delete-contents) nil t)))t)
      (setf contents-name (cdr (assoc "contents-name" conf)))
      (setf N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
      (setf password  (cdr (assoc "password" conf))))
   (clog :error "something is missing or wrong in the configuration file" cloud-dir)
#+END_SRC
In case ~cloud-directory~ configuration parameter is missing, let ask the user for the input:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(setf cloud-dir 
  (or (cdr (assoc "cloud-directory" conf))
      (read-string "cloud directory=" cloud-dir)))
#+END_SRC
At this point the configuration is o.k., so we can save it when we quit eamcs:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(add-hook 'kill-emacs-hook 'before-exit)
#+END_SRC
The file with the name given by =(all-passes)= contains individual passwords used to encode images;
even if we've got no images clouded so there are no passwords for them, this file should still exist:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (file-exists-p (all-passes))
  (write-region "" nil (all-passes))
  (add-files (all-passes)))
#+END_SRC
← and it must also be clouded.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(reset-Makefile)
(cloud-sync))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-fileDB()
  (let ((tmp-CCN (untilda (concat (local-dir) "CCN"))))
(or
(and
 (cloud-connected-p)
(= 0 (apply #'call-process
(append (list "gpg" nil nil nil)
(split-string (format
"--batch --yes --pinentry-mode loopback --passphrase %s -o %s --decrypt %s"
password tmp-CCN (concat cloud-dir contents-name ".gpg"))))))
 (progn (read-fileDB* tmp-CCN)
	(if cloud-delete-contents
	    (safe-dired-delete tmp-CCN) t)))
(progn (clog :error "cloud-start header failed") nil))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-conf (file-name)
  "reads configuration file"
(clog :debug "read-conf")
  (find-file (local-config)) (goto-char (point-min)); opening config file
  (let (res str (BN (buffer-name)))
    (while (and
	    (setf str (buffer-substring-no-properties (point) (line-end-position)))
	    (< 0 (length str)))
     (if (string-match "^\\(\\ca+\\)=\\(\\ca+\\)$" str)
	 (push (cons (match-string 1 str) (match-string 2 str)) res)
       (clog :error "garbage string in configuration file: %s" str))
(forward-line))
(kill-buffer BN)
    res))
#+END_SRC

* In case of emergency
Saving database to a file:
#+BEGIN_SRC 
(defun write-fileDB-full (DBname)
  (with-temp-file DBname
    (dolist (file-record  file-DB)
          (progn (insert (format-file file-record)) (newline)))))
(write-fileDB-full "/home/shalaev/cloud.db")
#+END_SRC

* Packaging
(Not finished.)
#+BEGIN_SRC emacs-lisp :tangle generated/cloud-pkg.el
(define-package "cloud" "0.1" "secure cloud file synchronization" '(cl epg dired-aux)
:keywords '("cloud" "gpg" "synchronization")
:url "https://cloud.leanws.com"
:authors '(("Oleg Shalaev" . "oleg@chalaev.com"))
:maintainer '("Oleg Shalaev" . "oleg@chalaev.com"))
;; Local Variables:
;; no-byte-compile: t
;; End:
;;; cloud-pkg.el ends here
#+END_SRC
