#+TITLE: emacs-based secure cloud storage for text files
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

Uses ~macros.el~, ~functions.el~, and ~logging.el~ from the [[https://notabug.org/shalaev/elisp-goodies][elisp-goodies]] project.

Github vs Emacs: since ~github~
1. does not understand ~org-mode~ internal links,
2. does not show calculation results from ~org~ files and
3. can not hide selected sections (thus making the web page too long),
consider opening this file in ~emacs~ instead of watching it online.

* Symmetric (en/de)cryption
All hosts (computers) are treated identically – there is no "main" host. This is why we use symmetric encryption
with automatically generated password. 
For (en/de)cryption, emacs will call shell commands similar to
#+BEGIN_SRC shell
gpg --pinentry-mode loopback --passphrase "somepass" -o /mnt/cloud/abc.gpg --symmetric ~/myFile.txt
gpg --pinentry-mode loopback --passphrase "somepass" -o ~/myFile.txt --decrypt /mnt/cloud/abc.gpg
#+END_SRC

* Initialization
[[https://stallman.org/][Stallman]] recommends not to use  ~CL~, but for now I am still requiring it.
** Local configuration
*** variables (configuration parameters)
The variables with the names starting with "cloud-" should probably be kept global; the others will be "localized".

=cloud-file-hooks= is used for special files (e.g., diary or bookmarks);
When those are copied from the cloud to the local hard drive, one should call, e.g., =diary-view-entries= or =bookmark-load=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from cloud.org
(defvar password nil); to be read from config or generated
(defvar N-CPU-cores 1)
(defvar cloud-file-hooks nil "for special files treatment")
#+END_SRC
← for example, after we have updated local ~emacs-diary~ file from the cloud, we may want to re-scan it.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar upload-queue nil "names of edited files")
(defvar added-files nil "newly clouded files")
#+END_SRC

From time to time (e.g., when we =M-x cloud-sync=)  we synchronize local information
with the remote file whose (secret) name is stored in =remote/files=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar remote/files nil "encrypted DB (without .gpg suffix) stored on the server")
(defvar remote-dir  "/mnt/cloud/")
(defun remote/files() remote/files)
(defun remote-dir() remote-dir)
(defun remote-files() (concat (remote-dir) remote/files ".gpg"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar emacs-d "~/.emacs.d/")
(defvar cloud-was-connected t "normally t, nill when there was no connection")
#+END_SRC
← ~cloud-was-connected~ is set to ~nil~ when ~(cloud-sync)~ fails, and is set to ~t~ once =(read-fileDB)= succeeds.

Similarly to how they do it in ~JavaScript~, let me call the following functions "dynamic variables":
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun local-dir() (concat emacs-d "cloud/"))
(defun cloud-mk() (concat (local-dir) "cloud.mk"))
(defun lock-dir() (concat (remote-dir) "now-syncing/"))
(defun lock-file() (concat (lock-dir) (system-name)))
(defun image-passes() (concat (local-dir) "individual.passes"))
(defun local/() (concat (local-dir) (system-name) "/"))
(defun local/log() (concat (local/) "log"))
#+END_SRC

Instead of storing configuration in =~/.emacs= I prefer to store it in a separate file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun local/config() (concat (local-dir) (system-name) "/config"))
#+END_SRC
This is because
1. sometimes the code will update its configuration, and
2. in this way configuration data is more separated from other ~elisp~ programs.

*** creating (only once, during the first run)
Before we start for the very first time, when cloud directory is inexistent or empty, 
we create the password for encryption by =(cloud-init)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-init() "initializes cloud directory and generates password -- runs only once"
(clog :info "atempting to create new configuration for this host")
;;(when (yes-or-no-p "Is cloud mounted?")
;;(setf remote-dir (read-string "cloud directory=" remote-dir))
(ifn (member (safe-mkdir remote-dir) '(:exists t))
(clog :error "could not create/access directory %s" remote-dir)
#+END_SRC
For safety reasons refusing to initialize a directory already containing encrypted files:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(if (directory-files remote-dir nil "^.\+.gpg$" t)
    (clog :error "please clean the directory %s before asking me to initialize it" remote-dir)
(clog :info "creating (main) remote file DB in unused directory %s" remote-dir)
(ifn-set ((remote/files (new-file-name remote-dir)))
  (clog :error "could not create DB file in the directory %s" remote-dir)
#+END_SRC
Generating random password and saving it in the local configuration file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(setf password (rand-str 9))
#+END_SRC
– one password for all text files – 
for now this software is designed for single person only, and I do not see why should I use individual passwords for different
text files. Note that I already use individual passwords for images so (from the technical point of view) it is easy to use
individuall passwords for some (or all) text files ← might facilitate gradual password replacement.

The concept "one password for many text files" might be changed later if I ever upgrade the code for sharing files within a group of people;
but if this happens, I will probably have to abandon symmetric encryption and deal with public/private keys.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (member (safe-mkdir (local-dir)) '(:exists t))
  (clog :error "could not create/acess directory %s" (local-dir))
(write-conf)
(clog :info "use M-x cloud-add in the dired to cloud important files and directories" ))))))
#+END_SRC

*** reading and writing
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun write-conf()
(clog :debug "starting write-conf")
(with-temp-file (local/config)
  (insert (format "remote/files=%s" (remote/files))) (newline)
  (insert (format "password=%s" password)) (newline)
  (insert (format "number-of-CPU-cores=%s" N-CPU-cores)) (newline)
  (insert (format "remote-directory=%s" remote-dir)) (newline)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-conf()
  "reads configuration file"
(let (conf)
(needs-set
  ((conf (read-conf* (local/config)))
   (remote/files (cdr (assoc "remote/files" conf)) (clog :error "specify 3-symbol contents name \"remote/files\" in %s" (local/config)))
   (N-CPU-cores (string-to-number
 (or
 (cdr (assoc "number-of-CPU-cores" conf))
 (clog :warning "specify number-of-CPU-cores in %s" (local/config)
 "1"))))
   (password (cdr (assoc "password" conf)) (clog :error "specify password in %s" (local/config)))
   (remote-dir (cdr (assoc "remote-directory" conf)) (clog :error "specify remote-directory in %s" (local/config))))
conf)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-conf* (file-name)
  "reads configuration file"
(with-temp-buffer
(safe-insert-file (local/config))
  (let (res str)
    (while (< 0 (length (setf str (read-line))))
     (if (string-match "^\\(\\ca+\\)=\\(\\ca+\\)$" str)
	 (push (cons (match-string 1 str) (match-string 2 str)) res)
       (clog :error "garbage string in configuration file: %s" str)))
    res)))
#+END_SRC

** Host/Action/File information
*** general
We got three variables (or databases) describing
1. host names participating in file synchronization,
2. actions to be performed on other hosts, and
3. names of the clouded files:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar cloud-hosts nil "host names participating in file synchronization")
(defvar remote-actions nil "actions to be saved in the cloud")
(defvar file-DB nil "list of vectors, each corresponding to a clouded file")
#+END_SRC
← The content of these variables is stored
1. in RAM: (=cloud-hosts=, =remote-actions=, =file-DB=),
2. in local file named =(local/all)=
3. on the server, in a file named =remote/files=.

Every element of ~file-DB~ is a vector having the following structure:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar file-fields; indices numerating array fields
(list 'plain; original (local) file name
'cipher; encrypted file name (base name)
'mtime; modification time
'modes; permissions
'uname; user name (obsolete and unused)
'gname)); group name
(let ((i 0)) (dolist (field-name file-fields) (setf i (1+ (set field-name i)))))
#+END_SRC

*** hosts and actions
The content of ~file-DB~ is locally stored in the file named =(local/all)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun local/all() (concat (local/) "all"))
#+END_SRC

*** printing
**** hosts
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun print-hosts()
(dolist (hostname cloud-hosts) (insert (format "%s " hostname)))
(backspace)
(newline))
;;(clog :debug "print-hosts finished"))
#+END_SRC
**** actions
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun print-actions()
(clog :debug "print-action started")
(dolist (action (reverse remote-actions))
  (insert (format-action action))
  (drop remote-actions action)
  ;;(backspace) 
(newline)))
#+END_SRC
**** file info
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun format-file (DB-rec)
  (format "%S %s %s %s %d %S"
	  (tilda (aref DB-rec plain))
	  (aref DB-rec cipher)
	  (aref DB-rec uname)
	  (aref DB-rec gname)
	  (aref DB-rec modes); integer
	  (format-time-string "%F %H:%M:%S %Z" (aref DB-rec mtime))))
#+END_SRC

*** parsing
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun safe-FL()
  (if (< (line-end-position) (point-max))
     (forward-line)
     (move-end-of-line 1)))
(defun read-line()
(let ((str (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
 (safe-FL)
 str))
(defun cut-line() 
(let ((str (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
  (delete-region (line-beginning-position) (progn (safe-FL) (point)))
   str))
#+END_SRC

**** action lines
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun parse-action(str)
(clog :debug "parse-action(%s) ..." str)
(let ((action (make-vector (length action-fields) nil)))
#+END_SRC
An action string has unknown number of fields (columns); some of them are quoted and may contain spaces, others are not.
We use =begins-with= from ~common.el~ to read the fields.

Let us parse the string =str= and save extracted parameters (values) in the vector =action=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (column (list
                 `(:time-stamp . ,i-time)
                 `(:int . ,i-ID)
                 `(:int . ,i-Nargs)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
=(aref action i-Nargs)= must be evaluated _after_ =`(:int . ,i-Nargs)=, but _before_ we proceed with =(cons (cons  :string  (aref action i-Nargs)) i-args)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (column 
(list
  (cons (cons  :string  (aref action i-Nargs)) i-args)
       `(:strings . ,i-hostnames)))
  (needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
     (aset action (cdr column) (car col-value)); was (mapcar #'untilda (car col-value))
     (setf str (cdr col-value))))
#+END_SRC
So, we have just got information about pending action.
We perform it immediately if our hostname is in the list =(aref action i-hostnames)=.

In this sigle-user code action's time stamp =AID= may serve as its unique ID:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let ((AID (format-time-string "%02m/%02d %H:%M:%S" (aref action i-time))))
(clog :info "... will later be referenced as %s" AID)
(cons AID action))))
#+END_SRC

**** file lines
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun str-to-DBrec(str)
"parses one file line from the remote file DB"
(ifn (string-match "\"\\(.+\\)\"\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([^\s]+\\)\s+\\([[:digit:]]+\\)\s+\"\\(.+\\)\"" str)
(clog :error "Ignoring invalid file line %s" str)
#+END_SRC
We've got a valid string describing a clouded file, now let us parse it.
The first column is the file name:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let ((CF (make-vector (length file-fields) nil))
      (FN (match-string 1 str)))
  (aset CF plain FN)
  (aset CF cipher (match-string 2 str))
  (aset CF uname (match-string 3 str))
#+END_SRC
← actually the last field (=uname= stands for "user name") is obsolete and no more used: it is assumed that all files are owned by the user who runs the code.
(Later I will get rid of this field or replace it with another one.)

We syncronize ~gname~ (name of the group), ~modes~ (permissions), and ~mtime~ (modification time) for every file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
  (aset CF gname (match-string 4 str))
  (aset CF modes (string-to-number (match-string 5 str)))
  (let ((mtime-str (match-string 6 str)))
(ifn (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [[:upper:]]\\{3\\}" mtime-str)
(bad-column "file" 6 mtime-str)
(aset CF mtime (parse-time mtime-str))
CF)))))
#+END_SRC

** (En/De)cryption
Especially when ~(= 0 *log-level*)~ this code might print many log messages.
For most important ones I will use this function
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun end-log (fstr &rest args)
  "message + time"
  (push
   (apply #'format
	  (cons (concat
		 (format-time-string "%H:%M:%S " (apply 'encode-time (butlast (decode-time (current-time)) 3)))
		 fstr)
		args))
   important-msgs))
#+END_SRC
which is going to print them at the end of the syncronization session.

Some files require special treatment after they are updated on the local disk from the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun post-decrypt (FN)
  "special treatment for certain files"
  (let ((ext (file-name-extension FN))
	(name (file-name-base FN)))
    (when (string= FN (expand-file-name diary-file))
      (with-current-buffer (find-file-noselect (diary-check-diary-file))
	(clog :info "diary buffer opened or updated")))
     (when (member FN *loaded*)
       (end-log "*configuration changed, consider reloading emacs*")
    (clog :warning "consider reloading configuration file %s" FN)
    ;;   (load-file FN))
)))
#+END_SRC
where =diary-check-diary-file= will raise an error (exception) in case of inexisting diary-file.

** Other variables
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar removed-files  nil "files that were just removed (or renamed) on local host before (cloud-sync)")
#+END_SRC
← this variable serves to prevent recovering them from the cloud during the next =M-x cloud-sync=.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar important-msgs nil "these messages will be typically printed at the end of the process")
(defvar gpg-process nil "assyncronous make-process for (en/de)cryption")
#+END_SRC

* Connection with the cloud
Checking if the internet connection is established:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-connected-p()
  (and
   (remote-dir) (remote/files)
   (file-readable-p remote-dir)))
;;(file-readable-p (remote-files)
#+END_SRC
← note that =cloud-connected-p= should *not* be called before local file has been read by =read-conf=.

** SSH
Sometimes internet connection can be unstable or shut down unexpectedly,
so I added ~reconnect~ option to the ~/etc/fstab~ entry
(this probably will not work if you have to supply password to unlock the ssh key):
#+BEGIN_SRC 
# /etc/fstab
sshfs#shalaev@leanws.com: /mnt/lws fuse reconnect,users,auto 0 0
#+END_SRC
where "shalaev" is my user name, and ~leanws.com~ is the ssh-server (replace these with your values).

To limit the timeout to 30 seconds, update =~/.ssh/config= as follows:
#+name: ssh-config
#+BEGIN_SRC
# ~/.ssh/config
ServerAliveInterval 15
ServerAliveCountMax 2
#+END_SRC

** WebDav
=WebDav= is much slower than =ssh=, but it should be ok for file synchronization.
To mount ~yandex~ or ~pcloud~ to local directories ~/mnt/yd/~ and ~/mnt/pc~ I need three files:
~/etc/fstab~, ~/etc/davfs2/davfs2.conf~, and ~/etc/davfs2/secrets~
#+BEGIN_SRC 
# /etc/fstab
https://webdav.yandex.ru        /mnt/yd	davfs   user,noauto,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
https://webdav.pcloud.com	/mnt/pc	davfs	user,noauto,uid=shalaev,gid=shalaev,file_mode=0664,dir_mode=2775,x-systemd.device-timeout=20 0 0
#+END_SRC
where ~shalaev~ is my user name and group name; you must replace it with yours.

#+BEGIN_SRC
# /etc/davfs2/davfs2.conf
dav_user        davfs2
dav_group       davfs2
use_locks	0
cache_dir       /var/cache/davfs2 # system wide cache
cache_size      5000              # MiByte
delay_upload	0
#+END_SRC

#+BEGIN_SRC
# /etc/davfs2/secrets
/mnt/yd	myYandexLogin		password
/mnt/pc	myPCloudLogin		password
#+END_SRC

** FTP
Somehow I am not aware of /reliable/ way of mounting an ~ftp~ server to a directory in linux;
~emacs~ also seems to be bad in estsblishing ~ftp~ connections.
May be developers think that ~ftp~ is obsolete and ignore it;
personally I don't see anything wrong with it, especially when an ~ftp~ connection is established using SSL-encryption.

Probably the best way to improve FTP-support in emacs would be to write an eLisp-wrapper for [[http://lftp.yar.ru][lftp]] command.

* Remote file DB
This file stores [[Host/Action/File information][Host/Action/File information]] on the server.
** Writing
*** The first line: list of all hostnames
←  without quotes, separated by spaces.

In the following, ~DBname~ is the name of _decrypted_ remote file DB:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun write-all (DBname)
  (with-temp-file DBname
(print-hosts)
#+END_SRC
Probably I should *not* write the file if both =upload-queue= and =added-files= are nil.

The next block of lines contains information about pending [[Actions][actions]] →

*** Pending actions
In this block, every line is has the following fields (columns):
1. Time stamp,
2. (integer) action ID,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).
   Gets updated by =cloud-host-add= and =cloud-host-forget=.

The order of actions is important! For example, imagine that
I renamed or moved a file twice; the order of these actions on a remote host should be the as on the local one:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(print-actions)
#+END_SRC
Pending actions block is ended by an empty line separating it from the rest of the file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(newline)
#+END_SRC

*** List of clouded files
This is the last (and, usually, the largest) block of lines.
Here every line corresponds to one file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (file-record file-DB)
  (insert (format-file file-record)) (newline))
(setf removed-files nil) t))
#+END_SRC

** Parsing
*** list of host names
The function =read-all= (returns =nil=) reads (previously decrypted) [[Host/Action/File information][host/action/file information]]:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-all (DBname)
  "reads content (text) file into the database file-DB"
  (temp-open DBname
  (let (str)
(needs-set
 ((cloud-hosts
  (split-string (setf str (read-line)))
  (clog :error "invalid first line in the remote file DB %s" DBname)))
#+END_SRC
In case =read-all= is launched on an unknown computer
(that is, its hostname is not yet mentioned in the first line of the file =DBname=),
it is automatically added to the cloud network:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (member (system-name) cloud-hosts) (cloud-host-add))
#+END_SRC

*** list of pending actions
The concept of actions is explained in the [[Actions][corresponding section]].

Keep reading one action after another until we encounter an empty line:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(while (< 0 (length (setf str (read-line))))
(when-let ((AA (parse-action str)) (AID (car AA)) (action (cdr AA)))
  (ifn (member (system-name) (aref action i-hostnames))
      (clog :info "this host is unaffected by action %s" AID)
    (if (perform action)
	(clog :info "sucessfully performed action %s" AID)
      (clog :error " action %s failed, will NOT retry it" AID))
#+END_SRC
← even if the action failed, we wash our hands and not retry it.
If the action is still pending on some hosts, we will store it in =remote-actions=
which is going later to be saved into the [[Contents file][remote file DB]]:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when (drop (aref action i-hostnames) (system-name))
  (push action remote-actions)))))
#+END_SRC

An empty line ends the action reading loop;
the next thing to do is to read/parse the files' block of lines.

*** list of (clouded) files
For files that need to be (up/down)loaded (to/from) the cloud =(read-fileDB)= forms ~cloud.mk~
which can be fed to GNU make as =make --jobs=N -f cloud.mk=, where ~jobs~ parameter ~N~ is the (configurable) number of CPU cores.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
;;(forward-line)
(needs ((CDFs
#+END_SRC
← =CDFs= will contain the data about the files in the remote directory.

Our ~.gpg~ files are named as  ~XYZ.gpg~; the next line cuts the extension  ~.gpg~ away:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
 (mapcar #'(lambda(s) (replace-regexp-in-string "....$" "" s))
      (directory-files remote-dir nil "...\...." t)) (clog :error "can not read %s" remote-dir)))
(while (< 10 (length (setf str (read-line))))
(when-let ((CF (str-to-DBrec str)))
#+END_SRC
Ideally every file mentioned in =file-DB= should exist on a local hard disk.
In reality either file, the local one, or the remote one, or both, might be absent,
and we have to address all of these situations:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(let* ((FN (plain-name CF))
      (remote-file-exists (member FN CDFs))
      (local-file-rec (or (cloud-locate-FN FN)
(when-let ((LF (get-file-properties* FN)))
        (aset LF cipher (aref CF cipher))
        (push LF file-DB)
        LF))))
(cond
((not (or local-file-rec remote-file-exists))
 (clog :error "forgetting file %s which is marked as clouded but is neither on local disk nor in the cloud" FN)
 (drop file-DB CF))
((or
 (and (not local-file-rec) remote-file-exists)
 (and local-file-rec remote-file-exists (time< (aref local-file-rec mtime) (aref CF mtime))))
#+END_SRC
=download= queues the file for downloading from the cloud (by updating the [[Creating make file][make file]]):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(download CF))
((or
 (and local-file-rec remote-file-exists (time< (aref CF mtime) (aref local-file-rec mtime)))
 (and local-file-rec (not remote-file-exists)))
(upload CF))))))
t)))))
#+END_SRC
← similarly, =upload= queues the file for uploading to the cloud.

At this point we ended up parsing the list of files.
=(defun read-all ...)= ends here.

* On saving files in emacs
When the file is saved in emacs (=C-x s=), we mark it so that it is going
to be uploaded to the cloud when the user calls =cloud-sync= next time:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun touch (FN)
"called when the file named FN is changed"
(clog :debug "touch(%s)" FN)
(when (and FN (stringp FN))
  (when-let ((file-data (cloud-locate-FN (file-chase-links FN))))
    (aset file-data mtime (current-time))
    (upload file-data) t)))
(defun on-current-buffer-save()
  (touch (buffer-file-name)))
(add-hook 'after-save-hook 'on-current-buffer-save)
#+END_SRC
* Creating make file
Make file is useful because
1. it allows us to use multi-threading and
2. it simplifies debugging.

When the make file is ready, we launch it with =make -jN ~/.emacs.d/cloud/cloud.mk=, where =N= is the number of CPU cores. 
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(macrolet ((NL () '(push "
" Makefile))
(inl (&rest format-pars) `(progn (push ,(cons 'format format-pars) Makefile) (NL))))
(cl-flet ((pass-d()  (concat (local-dir) "pass.d/")))
(cl-flet ((updated() (concat (pass-d) "updated")))
(let (all Makefile uploaded
#+END_SRC
(Already encrypted) gpg-files types are not supposed to be encrypted, and images should be encrypted in a special way.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(specially-encoded '(
#+END_SRC
Already encrypted (~gpg~) files are just copied
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
("$(cloud)%s.gpg: %s
\tcp $< $@
" "gpg")
#+END_SRC
← this format string requires 2 arguments: =(aref file-record cipher)= and =(aref file-record plain)=.

Make stanza for encrypting an image is more sophisticated:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
("$(cloud)%s.png: %s %s
\tconvert $< -encipher %s%s $@
" "jpg" "jpeg" "png")))
#+END_SRC
← this format string requires 5 arguments:
=(aref file-record cipher)=, =(aref file-record plain)=, =(updated)=,
=(pass-d)=, and (once again) =(aref file-record cipher)=.

Similarly, for decoding
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(specially-decoded '(
("%s: $(cloud)%s.gpg
\tcp $< $@
" "gpg")
("%s: $(cloud)%s.png  %s
\tconvert $< -decipher %s%s $@
" "jpg" "jpeg" "png"))))
#+END_SRC
with the same number of arguments, as for encoding above.

** Creating ~make~ stanza for encoding one file
Non-standard case (an image or a ~gpg~-file):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(cl-flet ((enc-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-encoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr XYZ FN (updated) (pass-d) XYZ)
#+END_SRC
where ~XYZ~ is the (random) 3-symbol cloud name of the file (without extension).

All other files are treated with ~gpg~:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(format "$(cloud)%s.gpg: %s
\t@$(enc) $@ $<
" XYZ FN))
#+END_SRC
At the end of every file (en/de)coding stanza we send a message to the log file:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(format "\t-echo \"$(date): uploaded %s\" >> $(localLog)
" FN)))))
#+END_SRC
Here ends the function =enc-make-stanza= that produces make-stanza for encoding.

The decoding is similar:
** Creating ~make~ stanza for decoding one file
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dec-make-stanza(file-record)
(when-let ((XYZ (aref file-record cipher)) (FN (tilda (aref file-record plain))))
(let ((file-ext (file-name-extension FN)))
(concat
(if-let ((fstr (car (find file-ext specially-decoded :key #'cdr :test #'(lambda(x y) (member x y))))))
(format fstr FN XYZ (updated) (pass-d) XYZ)
(format "%s: $(cloud)%s.gpg
\t@$(dec) $@ $<
" FN XYZ ))
(format "\t-chgrp %s $@
\t-chmod %o $@
\t-touch --date=%S $@
\t-echo \"$(date): downloaded %s\" >> $(localLog)
" (aref file-record gname) (aref file-record modes) (full-TS (aref file-record mtime)) FN))))))
#+END_SRC

** Putting this all together
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun download (file-record)
(needs ((FN (aref file-record plain) (clog :error "download: file lacks plain name"))
        (stanza (dec-make-stanza file-record) (clog :error "download: could not create stanza for %s" FN)))
(push (format " %s" FN) all)
(push stanza Makefile) (NL)))
#+END_SRC

GNU make won't upload (with encryption) the file to the server if target is younger than the dependence.
=make-cloud-older= ensures that the ~.gpg~ file is old enough to prevent this behavior:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun make-cloud-older(file-record)
;;(clog :debug "make-cloud-older(%s)" (plain-name file-record))
(when-let ((clouded (get-file-properties (aref file-record cipher)))
           (local-mtime (aref file-record mtime)))
(when (time< local-mtime (aref clouded mtime))
(clog :debug "changing time stamp to %s" (FS (time-add local-mtime -60)))
  (set-file-times
(concat (remote-dir) (plain-name clouded) (cip-ext (plain-name file-record)))
(time-add local-mtime (- -60 (random 6000)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun upload (file-record)
(needs ((FN (tilda (aref file-record plain)) (clog :error "upload: file lacks plain name"))
	(CN (aref file-record cipher) (clog :error "upload: file %s lacks cipher name" FN))
	(stanza (enc-make-stanza file-record) (clog :error "upload: could not create stanza for %s" FN)))
;;(clog :debug "started upload(%s)" FN)
(unless (member FN uploaded)
(push FN upload-queue)
;;(clog :debug "will indeed upload(%s)" FN)
(make-cloud-older file-record)
(push FN uploaded)
(push (format " %s" (concat (remote-dir) CN
(cip-ext FN)))
all)
(push stanza Makefile) (NL))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun reset-Makefile()
"reseting make file"
(when (or (and (file-exists-p (pass-d)) (file-directory-p (pass-d))) (safe-mkdir (pass-d)))
(setf all nil Makefile nil uploaded nil)
(inl "cloud=%s" remote-dir)
(inl "password=%S" password)
(inl "gpg=gpg --pinentry-mode loopback --batch --yes")
(inl "enc=$(gpg) --symmetric --passphrase $(password) -o")
(inl "dec=$(gpg) --decrypt   --passphrase $(password) -o")
(inl "localLog=%s" (local/log))
(inl "MK=%s" (cloud-mk))
(inl "date=`date '+%%m/%%d %%T'`
")
(inl (concat (format "%s: %s
\tawk '{print $$2 > %S$$1}' $<
\techo $(date) > $@
\t-chgrp -R tmp %s*
" (updated) (image-passes) (untilda (pass-d)) (pass-d))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun save-Makefile()
"flushing make file"
(inl "all:%s
\techo \"background (en/de)cryption on %s finished $(date)\" >> %s
\t@sed 's/%s/******/g' %s > %s.bak
"
(apply #'concat all)
(system-name)
(concat (remote-dir) "history")
password (cloud-mk) (cloud-mk))
(write-region (apply #'concat (reverse Makefile)) nil (cloud-mk))))))))
#+END_SRC

* cloud-sync
=cloud-sync= is the most frequently used function.

We assume that files are changed only within emacs (either edited/saved or removed/renamed using ~dired~), so that
=file-DB= always contains the most recent information about clouded files.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-sync()
(interactive)
(let ((ok t))
#+END_SRC
Even if the cloud was changed by some other hosts, information from =(local/all)= is still valuable (for resolving collissions)
and must be loaded at start (when =file-DB= is empty):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless file-DB
 (clog :info "loading data from disk at start")
 (read-all (local/all)))
#+END_SRC
Now if we realize that clouded data is younger, we update the local one from it and =read-all= once again.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (cloud-connected-p) (clog :warning "remote directory not mounted, so we will not encrypt %s-->%s" (local/all) (remote-files))
  (directory-lock (lock-dir)
    (when (file-newer-than-file-p (remote-files) (local/all))
      (clog :info "detected NEW %s, will now update %s from it" (remote-files) (local/all))
      (ifn (gpg-decrypt (local/all) (remote/files))
	(setf ok (clog :error "could not decrypt file data from the cloud; SHUT DOWN the service and INVESTIGATE!"))
	(unless (read-all (local/all))
	  (setf ok (clog :error "could not parse file data from the cloud; SHUT DOWN the service and INVESTIGATE!")))))
#+END_SRC

If our host made the last updates on the server, and we have some data to save, let us update =(local/all)=, and (if possible) =(remote-files)=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when (or added-files upload-queue removed-files)
  (ifn (write-all (local/all)) (setf ok (clog :error "could not save data to %s" (local/all)))
    (gpg-encrypt (local/all) (remote/files))
    (setf added-files nil upload-queue nil)))
#+END_SRC

It is always easier to read local file, so let me make it a little bit younger than the (encrypted) remote one:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(set-file-times (local/all) (current-time))
#+END_SRC
Now let us copy the files from/to the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(save-Makefile)
(let ((make (format "make -j%d -f %s all &> %s.log" N-CPU-cores (cloud-mk) (cloud-mk))))
  (clog :debug "starting %s" make)
  (shell-command make)
  (clog :debug "finished %s" make))
(reset-Makefile)))
#+END_SRC

Finally let us print stored messages (printed by =end-log=):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(dolist (msg (reverse important-msgs)) (message msg))
(setf important-msgs nil)
(clog :info "done syncing")
(write-region (format "%s: %s -- %s
" (system-name)  (TS (current-time)) (format-time-string "%H:%M:%S" (current-time))) nil (concat (remote-dir) "history"))
ok))
#+END_SRC
=cloud-sync= ends here.

Let us =cloud-sync= before the user quits ~emacs~:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun before-exit()
;; (write-conf)
  (cloud-sync))
#+END_SRC
Note: if the connection with the cloud is unstable, an attempt to access the cloud can take more than 10 seconds.

So don't be surprised if quitting emacs takes a long time; the reason for that might be just broken connection to the cloud.
Let it wait for about 30 seconds, and it quits without syncing.
(The waiting time might depend on your [[ssh-config][ssh-configuration]].)

* Actions
By "action" I mean a pending order issued by another host.
For example, suppose that when I yesterday worked on my laptop, I have erased or renamed a file or a directory.
Today I came to my office and I want the same file/directory to be erased/renamed on my office computer.
Yesterday my laptop issued an order to erase/rename that file/directory on every host whoose name is
enumerated in =cloud-hosts=. This order will exist untill all hosts execute it, and then it will be forgotten.

** Definitions
Acctions can be applied to both files and directories. An action is a vector.
=(i-time i-ID i-args i-hostnames i-Nargs)= are integer indices, each pointing to a field in an action:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar action-fields '(i-time i-ID i-args i-hostnames i-Nargs))
(let ((i 0)) (dolist (AF action-fields) (setf i (1+ (set AF i)))))
#+END_SRC
where =i-Nargs= is used only when parsing action lines from the remote file DB.

=(i-forget i-delete i-rename i-host-add i-host-forget)= are integer IDs, each identifying some kind of action (e.g., "forget file/directory" or "delete file/directory"):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defvar action-IDs '(i-forget i-delete i-rename i-host-add i-host-forget))
(let ((i 0)) (dolist (AI action-IDs) (setf i (1+ (set AI i)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun new-action (a-ID &rest args)
  (let ((action (make-vector (length action-fields) nil)))
    (aset action i-ID a-ID)
    (aset action i-time (current-time))
    (aset action i-args args)
    (aset action i-hostnames (remove (system-name) cloud-hosts))
    (push action remote-actions)))
#+END_SRC
Later more actions will be introduced:
1. =i-reset-pass= for (gradual – not for all files at once) password renewal
2. =i-reset-names= for gradual renaming of the files in the cloud.

The function =perform= performs an action:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun perform(action)
(write-region
(format "%s: %s
" (TS (current-time)) (format-action action))
nil (local/log) t)
  (let ((arguments (aref action i-args)))
    (case* (aref action i-ID) =
      (i-host-forget (dolist (arg arguments) (drop cloud-hosts arg)) t)
      (i-host-add (dolist (arg arguments) (push arg cloud-hosts)) t)
      (i-forget (cloud-forget-many arguments) t)
      (i-delete (cloud-rm arguments) t)
      (i-rename (cloud-rename-file (first arguments) (second arguments)) t)
      (otherwise (clog :error "unknown action %d" (aref action i-ID)))))
   (drop remote-actions action) t)
#+END_SRC

We must inform other hosts about actions they have to perform; for that we write list of actions
to the remote file DB using the function
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun format-action (action)
  (format "%S %d %d %s %s"
(full-TS (aref action i-time)); 1. Time stamp,
(aref action i-ID); 2. (integer) action ID,
(length (aref action i-args)); 3. (integer) number of arguments for this action (one column),
(apply #'concat (mapcar #'(lambda(arg) (format "%S " (tilda arg))) (aref action i-args))); 4. [arguments+] (several columns),
(apply #'concat (mapcar #'(lambda(HN) (format "%S " HN)) (aref action i-hostnames))))); 5. hostnames, where the action has to be performed (several columns).
#+END_SRC
In this block, every line is has the following fields (columns):
1. time stamp: in emacs'es single-thread world, time stamp can uniquely identify an action,
2. (integer) identifying action type,
3. (integer) number of arguments for this action (one column),
4. [arguments+] (several columns),
5. hostnames, where the action has to be performed (several columns).

Since there is no hook on renaming or deleting files, we overwrite dired functions for renaming and deleting;
their new versions will now contain standard code plus mine.

Storing standard definitions of =dired-rename-file= and =dired-delete-file= in variables ~DRF~ and ~DDF~:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (boundp 'DRF) (defvar DRF (indirect-function (symbol-function 'dired-rename-file)) "original dired-rename-file function"))
(unless (boundp 'DDF) (defvar DDF (indirect-function (symbol-function 'dired-delete-file)) "original dired-delete-file function"))
#+END_SRC

Now let us write code for each of the following actions:
1. =delete= (created when a user removes a file or a directory in a dired buffer),
2. =cloud-host-add= (created when this code is launched on a computer, whose name is not mentioned in =cloud-hosts=,
3. =cloud-host-forget=,
4. =cloud-add=,
5. =cloud-forget=,
4. =cloud-rename= (called when the file/directory is renamed in ~dired~).

** Delete
We ovewrite standard emacs =dired-delete-file= function:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun dired-delete-file (FN &optional dirP TRASH)
  (let (failure (FN (tilda FN)))
#+END_SRC
Note that ~FN~ might be a directory.

IMHO, when ~FN~ is a directory, ~RECURSIVE~ (denoted by ~dirP~ here) must always be t!
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(condition-case err (funcall DDF FN dirP TRASH)
  (file-error
    (clog :error "in DDF: %s" (error-message-string err))
    (setf failure t)))
(unless failure
#+END_SRC
=file-DB= does *not* contain any directories, so if =FN= is a directory, the following block will do nothing:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(cloud-forget-recursive FN) (new-action i-delete FN)
(when dirP
  (dolist (sub-FN (mapcar #'plain-name (contained-in FN)))
    (when (cloud-forget-file sub-FN) (new-action i-delete sub-FN)))))))
#+END_SRC

The following function is used to perform pending delete ordered by another host:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-rm (args)
  (interactive) 
(let ((ok (cloud-forget-many args)))
  (dolist (arg args)
    (setf ok (and (safe-dired-delete arg) (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-many (args)
  (interactive) 
(let ((ok t))
  (dolist (arg args)
    (setf ok (and (cloud-forget-recursive arg) ok)))
ok))
#+END_SRC

When we rename or delete a folder, we have to perform similar action on every cloud file contained inside the folder.
The following function helps us finding such files:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun contained-in(dir-name); dir-name must end with a slash /
    (let (res)
      (dolist (DB-rec file-DB)
	(when(and
(< (length dir-name) (length (aref DB-rec plain)))
(string=(substring-no-properties (aref DB-rec plain) 0 (length dir-name)) dir-name))
	  (push DB-rec res)))
      res))
#+END_SRC

** Add/forget hosts
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun add-to-actions(hostname)
  (dolist (action remote-actions)
    (unless (member hostname (aref action i-hostnames))
      (aset action i-hostnames (cons hostname (aref action i-hostnames))))))
(defun erase-from-actions(hostname)
  (dolist (action remote-actions)
    (when (member hostname (aref action i-hostnames))
      (aset action i-hostnames (remove hostname (aref action i-hostnames))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-host-add ()
  "adding THIS host to the cloud sync-system"
(let ((hostname (system-name)))
  (unless (member hostname cloud-hosts)
    (push hostname cloud-hosts))
  (new-action i-host-add hostname)
  (add-to-actions hostname)))
#+END_SRC
As of 2020-10-20 =cloud-host-forget= is untested:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-host-forget ()
  "remove host from the cloud sync-system"
  (let ((hostname (system-name)))
    (when (yes-or-no-p (format "Forget the host %s?" hostname))
      (new-action i-host-forget hostname)
      (if (cloud-sync)
	  (safe-dired-delete (local/config))
	(clog :error "sync failed, so I will not erase local configuration")))))
#+END_SRC
** Add files
To add (or "cloud") a file I suggest opening a dired buffer, mark the files and then =M-x cloud-add=:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-add (&optional FN)
  (interactive)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (add-files (dired-get-filename)) nil)
    (unless
	(add-files (read-string "file to be clouded=" (if FN FN "")))
      (clog :error "could not cloud this file"))))
#+END_SRC
Pending upgrades for =cloud-add=:
1. =cloud-add= must become more user-friendly: let the user know that file(s) are sucessfully clouded, and
2. =cloud-add= must work with directories. This is, however, not so straightforward because I almost never want to cloud _all_ files within a directory.

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun add-file(FN)
(let ((FN (tilda FN)))
(unless (cloud-locate-FN FN)
  (needs ((GFP (get-file-properties* (file-chase-links FN)) (clog :error "Aborting attempt to cloud inexisting file %s" FN))
          (CN (new-file-name remote-dir)))
(push FN added-files)
    (aset GFP cipher CN)
    (push GFP file-DB)
    (upload GFP)
    (when (member (file-name-extension FN) '("jpeg" "png" "jpg"))
#+END_SRC
← here we assumed that files' extensions are low case; this restriction can be easilly waived.

Since we are clouding an image, we need to 
1. generate an individual password for it,
2. save this password in the "all-passwords" file whose name is given by =(image-passes)=, and
3. notify our code that "all-passwords" file was changed:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(write-region
  (format "%s %s
" CN (rand-str 18)) nil (image-passes) t)
(touch (image-passes)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun add-files(&rest names)
(when
  (dolist (FN names)
    (unless (cloud-locate-FN FN)
      (needs ((GFP (get-file-properties* (file-chase-links FN)) (clog :error "Aborting attempt to cloud inexisting file %s" FN))
              (CN (new-file-name remote-dir)))
	(aset GFP cipher CN)
	(push GFP file-DB)
	(when (member (file-name-extension FN) '("jpeg" "png" "jpg"))
#+END_SRC
← here we assumed that files' extensions are low case; this restriction can be easilly waived.

Since we are clouding an image, we need to 
1. generate an individual password for it,
2. save this password in the "all-passwords" file whose name is given by =(image-passes)=, and
3. notify our code that "all-passwords" file was changed:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(write-region
  (format "%s %s
" CN (rand-str 18)) nil (image-passes) t)
(touch (image-passes)))
(upload GFP))))
;;(save-Makefile)
ok))
#+END_SRC

** Forget files
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-file (local-FN); called *after* the file has already been sucessfully deleted
   (push local-FN removed-files)
  (needs ((DB-rec (cloud-locate-FN local-FN) (clog :info "forget: doing nothing since %s is not clouded" local-FN))
          (CEXT (cip-ext local-FN))
	  (cloud-FN (concat (remote-dir) (aref DB-rec cipher) CEXT) (clog :error "in DB entry for %s" local-FN)))
#+END_SRC
Remove image's individual password:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(when (string= CEXT ".png")
(clog :debug "forgetting password for %s" local-FN)
  (forget-password (aref DB-rec cipher)))
#+END_SRC
Remove file from the database and erase its encrypted copy in the cloud:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(drop file-DB DB-rec)
(push local-FN removed-files)
(safe-dired-delete cloud-FN)
 t))
#+END_SRC
← returns t if the file was clouded; otherwise does nothing and returns nil.

=cloud-forget-recursive= should be called *after* the file has already been sucessfully deleted:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget-recursive(FN)
(dolist (sub-FN (mapcar #'plain-name (contained-in FN)))
(cloud-forget-file sub-FN)))
#+END_SRC

=cloud-forget= is excecuted either
1. when a file/directory is removed or
2. manually from the dired buffer
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-forget (&optional FN)
  (interactive)
  (if (string= major-mode "dired-mode")
      (dired-map-over-marks (cloud-forget-recursive (dired-get-filename)) nil)
    (unless
	(cloud-forget-recursive (read-string "file to be forgotten=" (if FN FN "")))
      (clog :error "could not forget this file"))))
#+END_SRC

** Rename
=cloud-rename-file= updates the file data base *after* the file has already been sucessfully renamed:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-rename-file (old new)
  (let ((source (cloud-locate-FN old))
        (target (cloud-locate-FN new)))
(cloud-forget-recursive old)
    (cond
     ((and source target); overwriting one cloud file with another one
      (dolist (property (list mtime modes uname gname)) do
            (aset target property (aref source property)))
      (drop file-DB source))
     (source (aset source plain new))
     (target (setf target (get-file-properties* new))))))
#+END_SRC

Updating =dired-rename-file= by overwriting it:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun dired-rename-file (old-FN new-FN ok-if-already-exists)
  (let (failure)
    (clog :debug "DRF")
    (condition-case err
	(funcall DRF old-FN new-FN ok-if-already-exists)
      (file-error
       (clog :debug "DRF error!")
       (message "%s" (error-message-string err))
       (setf failure t)))
    (unless failure
      (clog :debug "launching my cloud rename %s --> %s" old-FN new-FN)
      (cloud-rename-file old-FN new-FN)
      (new-action i-rename old-FN new-FN))))
#+END_SRC

* Starting all this machinery
** Every time we start ~emacs~
I suggest running =(cloud-start)= from =~/.emacs= every time you restart ~emacs~ (see [[file:README.org::Quick start][README.org]]):
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun cloud-start()
  (interactive) (save-some-buffers)
(clog :debug "cloud-start: local/config = %s" (local/config))
(ifn-let ((conf (read-conf)))
(progn
  (clog :warning "could not read local configuration file, trying to (re)create configuration")
  (when (cloud-init)
  (clog :info "check newly created configuraion %s and then M-x cloud-start" (local/config))))
#+END_SRC
We have read configuration, and now let us check if it is correct:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(ifn (and
   (if-let ((CD (cdr (assoc "remote-directory" conf))))
	  (setf remote-dir CD)
	(setf remote-dir (read-string "cloud directory=" remote-dir))
	(write-conf) t)
   (setf remote/files (cdr (assoc "remote/files" conf)))
   (setf N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
   (setf password  (cdr (assoc "password" conf))))
(clog :error "something is missing or wrong in the configuration file" remote-dir)
#+END_SRC
In case ~remote-directory~ configuration parameter is missing, let ask the user for the input:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(setf remote-dir 
  (or (cdr (assoc "remote-directory" conf))
      (read-string "cloud directory=" remote-dir)))
#+END_SRC
At this point the configuration is o.k., so we can save it when we quit eamcs:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(add-hook 'kill-emacs-hook 'before-exit)
#+END_SRC
The file with the name given by =(image-passes)= contains individual passwords used to encode images;
even if we've got no images clouded so there are no passwords for them, this file should still exist:
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(unless (file-exists-p (image-passes))
  (write-region "" nil (image-passes))
  (add-files (image-passes)))
#+END_SRC
← and it must also be clouded.
#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(reset-Makefile)
(cloud-sync))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
(defun read-fileDB()
(clog :debug "starting read-fileDB")
(or
(and
;; (cloud-connected-p)
(= 0 (apply #'call-process
(append (list "gpg" nil nil nil)
(split-string (format
"--batch --yes --pinentry-mode loopback --passphrase %s -o %s --decrypt %s"
#+END_SRC
← Strange: there will be errors if I quote password by writing =--passphrase %S= instead of =--passphrase %s=!

#+BEGIN_SRC emacs-lisp :tangle generated/main.el
password (untilda (local/all)) (remote-files))))))
(read-all (local/all)))
(clog :error "cloud-start header failed") nil))
#+END_SRC

* In case of emergency
Saving database to a file:
#+BEGIN_SRC 
(defun write-fileDB-full (DBname)
  (with-temp-file DBname
    (dolist (file-record file-DB)
          (progn (insert (format-file file-record)) (newline)))))
(write-fileDB-full "/home/shalaev/cloud.db")
#+END_SRC

* Packaging
(Not finished.)
#+BEGIN_SRC emacs-lisp :tangle generated/cloud-pkg.el
(define-package "cloud" "0.1" "secure cloud file synchronization" '(cl epg dired-aux)
:keywords '("cloud" "gpg" "synchronization")
:url "https://cloud.leanws.com"
:authors '(("Oleg Shalaev" . "oleg@chalaev.com"))
:maintainer '("Oleg Shalaev" . "oleg@chalaev.com"))
;; Local Variables:
;; no-byte-compile: t
;; End:
;;; cloud-pkg.el ends here
#+END_SRC
